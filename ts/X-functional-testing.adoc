= TS-X Functional Testing Standards

All test code is subject to the same coding standards as application code.

== Unit tests

Working unit tests MUST be developed for every change, inclusive of back-end
and front-end changes.

Unit test coverage MUST be measured and SHOULD be ≥ 90% in trunk.

=== Mocking in unit tests

SQLite, optionally running in a container, MAY be used to implement tests where
integration with a database needs to be mocked.

=== Unit test coverage

We SHOULD NOT chase test coverage for the sake of it.

Putting an arbitrary benchmark on unit test coverage – eg. 90% – implies that
unit tests are our most valuable type of test. That is misleading.

Unit tests are useful in some scenarios. They can be used to test components
in isolation and are faster to run as they do not require booting of the
framework or the installation of dependencies.

However, unit tests that use mocking are tightly coupled to the implementation,
which means when the implementation changes, the test code (the mocks) needs
to change too.

In contrast, integration and feature tests – and higher-level tests more
generally – are agnostic about the implementation, and are therefore more
useful in TDD and refactoring.

Better to try to achieve 100% test coverage through a combination of unit and
integration/feature/e2e tests.

== Functional tests (aka feature tests)

Feature tests SHOULD be written in BDD style.

A functional test pack MUST be created for each application, and it MUST have
tests that cover the majority of the application's operations, such that
executing the test pack is enough to verify that the application is suitable
for customer use, without undertaking additional manual testing.

Functional tests MUST be automated wherever possible. Manual test scripts MUST
cover scenarios that cannot be practically automated.

Functional test packs MUST be suitable for use in regression testing.

For web applications, e2e browser tests SHOULD be done automatically, with
regular manual testing.

== API integration testing

Testing API integrations – ie. between services – MUST be done prior to
applications being released to production.

All integrations MUST be testable in dev/QA environments.

Applications SHOULD mock integrations in dev/QA environments.

== Test data

There MUST be sufficient test data to be able to demonstrate all the capabilities
of the application. This means that the capabilities of the software will be
easy to demonstrate, eg. by non-technical teams such as sales.

== Test-driven development

The goal is self-testing code. Test-driven development is the RECOMMENDED
approach to achieving that is test-driven development.

Done properly, test-driven development might be better described as test-driven
_design_.

TDD is a process in which we _design_ our software in a series of small –
actually, tiny – steps, which incrementally evolve our software into a higher
quality solution.

This is the real skill of TDD: to learn to take a more incremental approach to
design.

This is a million miles away from clever developers intuiting perfect solutions
before they start.

TDD creates a constraint/pressure on us to work in small steps. This is TDD's
real code value.

The more you practice TDD, the better you get at reactively steering the design,
rather than attempting to intuit it from the start.

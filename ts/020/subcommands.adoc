= Subcommands

If you have several tools that are closely related, you can make them easier to use by combining them under a single command. It means you have a single program that can share configuration, storage, flags and arguments, and help text. Therefore, overall complexity is greatly reduced. This is what Git and many other programs do very well.

Be consistent. Use the same arguments and flags across all the subcommands. Have similar output formatting and error handling. Prompt for input in the same way. And so on. Subcommands SHOULD feel like they're all parts of a cohesive program, rather than standalone programs under a common namespace.

Avoid ambiguous subcommands, and avoid having two subcommands that have similar names. Avoid, for example, having both `update` and `upgrade` subcommands. This is quite confusing. Disambiguate with extra words, eg. `update-dependencies`, `upgrade-latest`.

In complex programs with lots of objects, and lots of operations that can be performed on each of those objects, it is a common pattern to use two levels of subcommands, where one is a noun (referring to the object) and one is a verb (referring to the operation). You can use the `noun verb` or the `verb noun` pattern. The first seems to be the more common pattern — eg .`docker container create` — but either is fine as long as you are consistent.

Where subcommands are used in combination with flags, the positioning of flags within the subcommand structure SHOULD NOT be significant. By way of example, the following two commands SHOULD be equivalent. However, it is acknowledged that this is not always possible. You may be constrained by the runtime environment or the capabilities of your argument parser.

----
$ my-tool --flag subcmd
$ my-tool subcmd --flag
----

It is not recommended to design in default or "catch-all" subcommands. If you have a subcommand that's likely to be used the most, you might be tempted to let people omit it entirely for brevity's sake. For example, say you have a `run` command that wraps an arbitrary shell command:

----
$ mycmd run echo "hello world"
----

You could make it so that, if the first argument to `mycmd` is not the name of a subcommand, you assume the user means `run`:

----
mycmd echo "hello world"
----

This has a serious drawback. Now you can never add a subcommand named `echo` — or _anything at all_ — without risking breaking existing usages. If there's a script out there that uses `mycmd echo`, it will do something entirely different after that user upgrades to the new version of your tool. Oops. It is for this reason that you should avoid default or "catch-all" subcommands. Instead, require all subcommands to be explicitly invoked.

Also, don't allow arbitrary abbreviations of subcommands. For example, say your tool has an `install` subcommand. When you added it, you wanted to save users some typing, so you allowed them to type any non-ambiguous prefix, like `mycmd ins`, or even just `mycmd i`. Now you're stuck. You can't add any more commands beginning with `i`. There's nothing in principle wrong with aliases — saving on typing is good — but they should be explicit and remain stable.

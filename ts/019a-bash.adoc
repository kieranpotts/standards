= TS-19a: Bash
:toc: macro
:toc-title: Contents

This technical standard extends link:./019-sh.adoc[TS-19: Unix Shells] with guidelines for using the https://www.gnu.org/software/bash/[Bash shell] specifically. Everything in TS-19 applied here, too; TS-19a extends TS-19.

toc::[]

== Choosing Bash

Bash is the RECOMMENDED shell for scripts that will be used only internally within an organization. It is RECOMMENDED to standardize on Bash for _all_ Unix scripting across an organization, to promote code reuse.

For scripts that will be distributed outside of an organization, or otherwise to environments in which the shell is unknown or can't be controlled, it is RECOMMENDED to stick to POSIX-compliant syntax – as covered by the link:./019-sh.adoc[TS-19: Unix Shells] technical standard.

== File name extensions

Bash file names may have the `.sh` extension or no extension. Bash file names MUST NOT have other extensions such as `.bash`. Use the shebang (see below) to identify the target interpreter instead.

== Shebang (`#!`)

The first line of a Bash file MUST be the shebang (`#!`, also known as a hashbang). This indicates to the shell which interpreter to use. The classic Bash shebang is:

----
#!/bin/bash
----

But the env-style shebang is RECOMMENDED:

----
#!/usr/bin/env bash
----

The difference between the two is that the classic shebang bets everything on one path, while the env shebang looks for the Bash binary in more places, and thus the script has a greater chance of being successfully run across different environments.

[TIP]
======
If you're using the classic Bash shebang, and if you get an error similar to "command not found" when running the script, then almost certainly the path to the Bash interpreter is wrong for the current system. Use `whereis bash` or `find ./ -name bash` to find the path to the `bash` executable. Some possible locations include:

* `/bin/bash`
* `/sbin/bash`
* `/usr/local/bin/bash`
* `/usr/bin/bash`
* `/usr/sbin/bash`
* `/usr/local/sbin/bash`
======

If a script is written to be POSIX-compliant, use either of the following shebangs instead. This will trip the Bash program to executing the script in POSIX-compliant mode, equivalent to passing the `--posix` option to `bash` on the command line. Again, the second env-style shebang will have wider compatibility and is therefore RECOMMENDED.

----
#!/bin/sh
#!/bin/env sh
----

== Sourcing

Use the POSIX-compliant dot notation for sourcing files. The alternative `source` keyword is more explicit but less portable (it is a Bash extension).

[source,bash]
----
# ❌
source functions.sh

# ✅
. functions.sh
----

== Variables

In Bash, local variables can be used to scope data to the function the variable is declared in.

[source,bash]
----
hello="hello"

hello() {
  local hello="world"
  echo $hello # → "world"
}

echo $hello # → "hello" (not modified).
----

This syntax is Bash-specific and it is RECOMMENDED to use `local` for all variable declarations within functions, so as not to unnecessarily pollute the global namespace and to prevent unexpected overwrites of global variables. Pay particular attention to declaring loop variables as local, too – this is a common source of bugs:

[source,bash]
----
local i
for i in {1..5}; do
  echo $i
done
----

Where the `local` keyword is omitted, include a comment explaining why it is not used. There will be many use cases where functions are designed to update global variables – that's fine, just use comments to be explicit about your intent.

Variable declaration and assignment MAY be on different lines, but try to always initialize variables with meaningful default values.

[source,bash]
----
some_function() {
  local code=0
  # …
  code=2

  return ${code}
}
----

== Arrays

Arrays, which are a Bash-specific shell extension, are used to store lists of elements. This data structure is RECOMMENDED for safely expanding lists into individual elements, such as arguments given to a command or elements given to a loop. Arrays are perfect for these use cases – this is their intended purpose in the language design.

Arrays SHOULD NOT be used as a basic for constructing complex data structures – this is not their intended use case.

[source,bash]
----
declare -a flags

# ✅
flags=(--foo --bar='baz')           # Initial assignment of flags.
flags+=(--greeting="Hello ${name}") # Append to the list of flags.
mybinary "${flags[@]}"              # Expand the flags to an arguments list.

# ❌ This won't work as expected.
flags='--foo --bar=baz'
flags+=' --greeting="Hello world"'
mybinary ${flags}
----

== Functions

Prefer the POSIX-compliant function declaration syntax. It is cleaner, more readable, and more portable.

[source,bash]
----
# ❌ Explicit function declaration.
function some_function () {
  return 0
}

# ✅ Implicit function declaration.
some_function() {
  return 0
}
----

== Control flows

For conditional expressions, it is RECOMMENDED to use the Bash-specific double-bracket syntax, `[[ … ]]`, over `[ … ]`, `test`, and `/usr/bin/[`.

In older versions of Bash, using single bracket syntax with `&&` or `||` could cause syntax issues. Using the double bracket syntax is better, therefore, for backwards compatibility with older implementations of Bash.

The double bracket syntax is preferred for other reasons, too. It prevents pathname expansion and word splitting, which eliminates a common class of bugs in shell scripts. It also allows for regular expression matching, which the single bracket syntax does not support.

.Examples
[source,bash]
----
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi

if [[ "filename" == "f*" ]]; then
  echo "Match"
fi

# For comparison, this gives a "too many arguments" error as
# f* is expanded to the contents of the current directory.
if [ "filename" == f* ]; then
  echo "Match"
fi
----

For clarity, use `==` for equality rather than `=`, even though both work. The former requires the use of the preferred Bash-specific `[[ … ]]` syntax. The latter can be confused with an assignment.

[source,bash]
----
#  ✅
if [[ "${my_var}" == "val" ]]; then
  do_something
fi

# ❌
if [[ "${my_var}" = "val" ]]; then
  do_something
fi
----

Be careful when using `<` and `>` in `[[ … ]]`, which performs a lexicographical comparison. Use `(( … ))` or `-lt` and `-gt` for numerical comparison.

[source,bash]
----
#  ✅
if (( my_var > 3 )); then
  do_something
fi

#  ✅
if [[ "${my_var}" -gt 3 ]]; then
  do_something
fi

# ❌ Probably unintended lexicographical comparison.
# True for 4, false for 22.
if [[ "${my_var}" > 3 ]]; then
  do_something
fi
----

Prefer to use `-z` and `-n` to test for zero-length and non-empty strings respectively. Alternatively you can do an equality check against a literal `""` value, but if you do ensure that you quote on the empty side.

[source,bash]
----
#  ✅
if [[ -z "${my_var}" ]]; then
  do_something
fi

# ✅
if [[ -n "${my_var}" ]]; then
  do_something
fi

# ✅ This is okay, but ensure quotes on the empty side.
if [[ "${my_var}" == "" ]]; then
  do_something
fi

# ❌ Be explicit and use `-n` here.
if [[ "${my_var}" ]]; then
  do_something
fi

# ❌ Do not use filler characters, like this. It feels a bit hacky.
if [[ "${my_var}X" == "some_stringX" ]]; then
  do_something
fi
----

Be careful about porting Bash scripts, which use the double-bracket `[[ … ]]` syntax, to other shells. Other shells have adopted this syntax, too, but the behavior is not consistent across all of them. Thus, the behavior of a script using this syntax could be inconsistent if executed in different shells.

In loops, Bash supports omitting the `in "$@"` part of a `for` loop. But it is RECOMMENDED to maintain this, for clarity.

[source,bash]
----
for arg in "$@"; do
  echo "${arg}"
done
----

== Arithmetic

Arithmetic expressions MUST be written using `(( … ))` or `$(( … ))`, and MUST NOT use the `$[ … ] syntax, the `expr` command, or the `let` built-in.

[source,bash]
----
# ❌ This Bash syntax is deprecated and non-portable.
i=$[2 * 10]

# ❌ Unquoted assignments using `let` are subject to globbing word-splitting.
let i="2 + 2"

# ❌ The expr utility is an external program, not a shell built-in, and is
# many times slower than the built-in `(( … ))` syntax for arithmetic. There
# are other issues with using `expr` too, such as inconsistencies with the
# handling of quoting.
i=$( expr 4 '*' 4 )
----

Numerical comparison MUST NOT be performed inside `[[ … ]]` expressions, either. In this context, the `<` and `>` operators perform lexicographical comparison instead. For _all_ numeric comparisons use ` (( … ))`.

[source,bash]
----
if (( a < b )); then
  …
fi
----

Variables MAY be referenced verbatim inside `$(( … ))`. Bash knows to look up `var` for you; you don't need to write `${var}` or even `$var`. Referencing variables consistently throughout a script is RECOMMENDED, but inside `$(( … ))` is the one exception where you MAY omit the `${…}` wrapping syntax. This produces slightly cleaner code and tends to read better in the context of arithmetic expressions.

[source,bash]
----
hr=2
min=5
sec=30
echo "$(( hr * 3600 + min * 60 + sec ))" # → 7530
----

In the following example, note the use of `$(( … ))` within a string.

[source,bash]
----
echo "$(( 2 + 2 )) is 4"
----

It is recommended to avoid using `(( … ))` as a standalone statement. But it's okay sometimes. In the following example, the result of a calculation is assigned to a variable.

[source,bash]
----
(( i = 10 * j + 400 ))
----

''''

== References

* https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html[Bash reference manual]

* https://github.com/dylanaraps/pure-bash-bible[Pure Bash bible] by Dylan Araps

* https://tldp.org/LDP/Bash-Beginners-Guide/html/[Bash guide for beginners] by Machtelt Garrels

* https://tldp.org/LDP/abs/html/[Advanced Bash scripting guide] by Mendel Cooper

* https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html[BASH Programming - Introduction HOW-TO] by Mike G

* https://mywiki.wooledge.org/BashGuide[BashGuide], written by various authors.

* https://guide.bash.academy/[The Bash guide] by Maarten Billemont (work-in-progress)

* https://web.archive.org/web/20230331215718/https://wiki.bash-hackers.org/[The Bash hackers wiki], community-maintained documentation (archived).

* https://en.wikibooks.org/wiki/Bash_Shell_Scripting[Bash shell scripting], a Creative Commons wiki-book by various authors.

* https://jvns.ca/blog/2017/03/26/bash-quirks/[Bash scripting quirks and safety tips] by Julia Evans

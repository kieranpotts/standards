= TS-19a: Bash
:toc: macro
:toc-title: Contents

This technical standard extends link:./019-sh.adoc[TS-19: Unix Shells] with specific guidelines for using the https://www.gnu.org/software/bash/[Bash shell].

This technical standard assumes that you are writing scripts that are specifically intended to be executed by Bash shells, and not by other Unix shells. If portability is a requirement, it is RECOMMENDED to write generic POSIX-compliant scripts that can be interpreted and executed by any POSIX-compliant shell. See link:./019-sh.adoc[TS-19: Unix Shells] for guidelines on writing POSIX-compliant shell scripts.

toc::[]

== Static analysis

It is RECOMMENDED to run https://github.com/koalaman/shellcheck[ShellCheck] against all Bash scripts.

== Files

The `.sh` file extension is not required for the Bash executable to run a Bash program file. It is RECOMMENDED to omit the extension on files that are intended to be used as executable commands, but to keep the `.sh` extension for Bash libraries (for easier identification of the language the libraries are written in).

== Shebang (`#!`)

The first line of a Bash file MUST be the shebang (`#!`, also known as a hashbang). This indicates to the shell which interpreter to use. The classic Bash shebang is:

----
#!/bin/bash
----

But the env-style shebang is RECOMMENDED:

----
#!/usr/bin/env bash
----

The difference between the two is that the classic shebang bets everything on one path, while the env shebang looks for the Bash binary in more places, and thus the script has a greater chance of being successfully run across different environments.

[TIP]
======
If you're using the classic Bash shebang, and if you get an error similar to "command not found" when running the script, then almost certainly the path to the Bash interpreter is wrong for the current system. Use `whereis bash` or `find ./ -name bash` to find the path to the `bash` executable. Some possible locations include:

* `/bin/bash`
* `/sbin/bash`
* `/usr/local/bin/bash`
* `/usr/bin/bash`
* `/usr/sbin/bash`
* `/usr/local/sbin/bash`
======

If a script is written to be POSIX-compliant, use either of the following shebangs instead. This will trip the Bash program to executing the script in POSIX-compliant mode, equivalent to passing the `--posix` option to `bash` on the command line. Again, the second env-style shebang will have wider compatibility and is therefore RECOMMENDED.

----
#!/bin/sh
#!/bin/env sh
----

== Comments

Use comments to explain the purpose of the script and any complex logic.

// TODO: Explain how to document functions, etc.

== Variables

In scripts, try to define all the script's variables at the top of the script.

Use descriptive names, eg. `log_file` not `lf`.

Use ALL_CAPS for exported variables – ie. environment variables that will be made available to all child processes spawned from the current shell. Example: `export PATH="/usr/local/bin:$PATH"`.

Prefer the bracketed syntax for variable expansion:

[source,bash]
----
# SHOULD NOT use:
$var

# RECOMMENDED:
${var}
----

The bracketed syntax is more robust and flexible. Because the brackets clearly delimit the variable name, it is easier to append literal characters immediately after the variable expansion, eg. `${var}bar`. In addition, the bracketed syntax can be extended to query and manipulate values returned from variable substitution. For example, `${#var}` returns the length of a string value, `${var:0:1}` returns the first character of the value, and so on. It is also possible to provide default (fallback) value in case the variable is empty.

Always quote variables with string values. This prevents word splitting and globbing issues.

[source,bash]
----
# SHOULD NOT do this for string values:
echo ${var}

# RECOMMENDED:
echo "${var}"
----

The risk of not quoting variables is demonstrated by the following code example.

[source,bash]
----
filename="My File.txt"

rm ${filename}       # Interpreted as: `rm My File.txt` → error
rm "${filename}"     # Interpreted as: `rm "My File.txt"` → correct
----

=== Input variables

Always validate user input variables.

=== Command substitution

Prefer the newer syntax, `var=$(command)`, over the older syntax (which still works), `var=`command``.

== Functions

Prefer Bash's implicit function declaration syntax over the POSIX-standard explicit syntax. It is cleaner, more readable, and more portable.

[source,bash]
----
# Explicit declaration.
function some_function () {
  return 0
}

# Implicit declaration.
some_function () {
  return 0
}
----

== Conditionals

For conditional expressions, it is RECOMMENDED to use the Bash-specific double-bracket syntax, `[[ ... ]]`, over the POSIX-compliant single-bracket syntax, `[ ... ]`.

In older version of Bash, using single bracket syntax with `&&` or `||` could cause syntax issues. Using the double bracket syntax is better, therefore, for backwards compatibility with older implementations of Bash.

The double bracket syntax is preferred for other reasons, too. It prevents pathname expansion and word splitting, which eliminates a common class of bugs in shell scripts. It also allows for regular expression matching, which the single bracket syntax does not support.

.Examples
[source,bash]
----
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi

if [[ "filename" == "f*" ]]; then
  echo "Match"
fi

# For comparison, this gives a "too many arguments" error as
# f* is expanded to the contents of the current directory.
if [ "filename" == f* ]; then
  echo "Match"
fi
----

''''

== References

* https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html[Bash reference manual]

* https://github.com/dylanaraps/pure-bash-bible[Pure Bash bible] by Dylan Araps

* https://tldp.org/LDP/Bash-Beginners-Guide/html/[Bash guide for beginners] by Machtelt Garrels

* https://tldp.org/LDP/abs/html/[Advanced Bash scripting guide] by Mendel Cooper

* https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html[BASH Programming - Introduction HOW-TO] by Mike G

* https://mywiki.wooledge.org/BashGuide[BashGuide], written by various authors.

* https://guide.bash.academy/[The Bash guide] by Maarten Billemont (work-in-progress)

* https://web.archive.org/web/20230331215718/https://wiki.bash-hackers.org/[The Bash hackers wiki], community-maintained documentation (archived).

* https://en.wikibooks.org/wiki/Bash_Shell_Scripting[Bash shell scripting], a Creative Commons wiki-book by various authors.

* https://jvns.ca/blog/2017/03/26/bash-quirks/[Bash scripting quirks and safety tips] by Julia Evans


= Design for change

The ultimate quality of a software system is its ability to be changed.

Every software application exists to meet a need. The challenge is that it's not always clear what those needs are, so the requirements are often vague and incomplete. There's rarely an obvious solution either, with all the options involving different trade-offs. These are the sorts of *wicked problems* that software developers routinely face.

.Wicked problems
****
A wicked problem lacks a clear definition and has no obvious solution. Horst Rittel and Melvin Webber coined the term in their 1973 paper "Dilemmas in a General Theory of Planning", using it to describe the complex issues they faced in their work as urban planners. The concept has since been applied to other fields, including software development.
****

Even for continuously-released software, like web apps, choosing which features to prioritize for the next update can be difficult. Rarely is there a shortage of ideas. What is hard is knowing which ones will deliver the most value to users.

https://ai.stanford.edu/~ronnyk/ExPThinkWeek2009Public.pdf[A 2009 internal research paper by Microsoft] found that only one in three product experiments – done using techniques like A/B testing – lead to meaningful improvements in the metrics they were meant to improve. This means two-thirds of product ideas did not deliver the value expected of them. The failure rate will likely be higher still in companies with less mature product development practices than at Microsoft. Some studies suggest that up to https://www.split.io/blog/the-80-rule-of-software-development/[80% of features] in your average software product are rarely or never used.

Of course, it's true for all kinds of products that we can't always know up-front if developing a new feature will be worth it. But this problem seems to be especially acute in the development of software products.

Even when requirements are known, they are rarely stable. Software requirements tend to change over time, and sometimes in unpredictable ways. In enterprise application software, requirements change with internal business needs and outside factors like regulations and market conditions. Worse, different stakeholders within a business can have conflicting requirements and different priorities – a common issue. In consumer software, it is often the case that lots of product iteration is necessary before good product-market fit is found.

[quote, Steve Jobs]
____
People don't know what they want until you show it to them.
____

In some cases, we may not even know what problem we're trying to solve with the software we're developing. This is often the case in R&D projects, or when building software for new business models. Innovative software products are developed through exploration and experimentation. Requirements are discovered, not known.

Of course, some software projects _do_ have known and stable requirements from the start. Replatforming projects, in which an old system is fully replaced by a new one with like-for-like functionality, is one example. But even these projects face some uncertainty. At the very least there's the maintenance costs. All software requires ongoing maintenance: dependencies will need to be updated; newly discovered vulnerabilities patched; code and configuration may need reworking for compliance with new standards or new runtime environments; and so on.

If software is not maintained, *software rot* sets in. This term describes the observation that computer programs tend to decline in performance over time, even if nothing appears to change. That happens because all software relies on other software and hardware, like operating systems and utilities, and those dependencies will themselves change over time. Therefore, all software must be continually maintained to keep it working properly in the changing computing environment in which it operates.

Even computer programs that are relatively isolated from the real world will depend on hardware, operating systems, and runtime environments – all of which will change over time – and thus they too will require ongoing maintenance to keep them working properly.

Maintenance requirements cannot be fully known in advance.

''''

There are all sorts of reasons why we may need to make changes to a piece of software after its initial construction. We may need to add new features, remove unused ones, fix bugs, improve performance, update dependencies, patch vulnerabilities, migrate data, increase capacity… and so on, and so on. Most software systems remain in a perpetual state of continuous development and/or maintenance. Unlike most physical products, most software is never truly finished.

A universal truth of _all_ software projects is that *requirements are emergent*. The degree to which requirements emerge varies from project to project, and over the life span of an individual project. But it is almost always the case that requirements will evolve, to some degree, after construction has started – no matter how hard you try to lock down the requirements at the start.

At least we have an advantage over the development of physical products. We can change software after it is delivered. The clue is in the name. Software is _soft_. It is malleable and changeable by nature. We can make software do different things by simply changing bits of its code and configuration. Usually, we don't need to redevelop the whole thing. This is not the case with most physical goods.

The natural response to the inherent uncertainty in software projects is to try to lock down requirements early. A better strategy is to leverage software's malleability and design our software to be easily changed.

// TODO: Contracts "high-level design" section:
//
// If we can achieve that, we will not need to wait on everything being perfectly planned before we get started on the construction. We can start to write the code even while the requirements remain vague and incomplete. As the requirements become clearer with time, we can change the code to meet the evolving requirements.

Systems that are easy to change tend to have long useful lives and deliver high returns on their investment.

Changeability – also known as evolvability – is the ultimate quality of a software system. But achieving it requires up-front and ongoing effort in software design. Changeability is a quality that is built-in to the code hierarchies, data structures, and communication patterns of software. It does not happen by accident. It requires deliberate, thoughtful design.

// Good software design is about finding good solutions to problems. It is also about having a plan to adapt to changing problems.

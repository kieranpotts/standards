= Settle the high-level design early

That said, some amount of up-front requirements gathering and solution design, before construction begins, is always useful.

The design work we _do_ want to do up-front is the stuff that is going to be difficult to change later. Changing the programming language in which an application is written is always going to be expensive. Rerouting the patterns of communication between different parts of a distributed system will always be a delicate operation. Moving data in a live production system will always be fraught with risk.

Anything that involves changing the fundamental structures of code and data, or the patterns of communication, is never going to be easy to change. So these are the sorts of design decisions we want to deal with as early as possible in a project. We do that by establishing a *high-level design* for the software before its construction begins.

The high-level design establishes the overall architectural style of an IT solution. It determines the boundaries between modules, the interfaces and communication patterns between modules, how state will be managed, and the choices of programming languages, database systems, and other infrastructure and tools. And much else besides.

The problem is we need to make these high-level design decisions at exactly the time when we know the least about the software requirements. This is the software *project paradox*. How can we be expected to make good choices about things we know will be expensive to change our minds on later, at a time when we have the least information to guide those choices?

One option is to apply the iterative and incremental approach to the high-level design. We can start construction with some rough ideas about how the software's code and data should be organized, and then refine the design iteratively as we learn more about the requirements over time. This is known as *evolutionary design* or *emergent design*. It is more than just evolving low-level details through refactoring. It involves changing the fundamental architectural characteristics of the software, changing things like module boundaries, communication patterns, data structures, and even technology choices.

This approach has the advantage of allowing us to get cracking on the construction of the software as soon as possible. Unfortunately, evolutionary design has some big drawbacks. This methodology tends to lead to lots of wasted effort. It can get pretty expensive if you end up needing to tear down and remake significant chunks of a system – a common outcome of a purely evolutionary approach to high-level design. The ensuing project delays and the costs of rework can blow out schedules and budgets, undermining confidence in a project just as it's getting going.

A better approach tends to be to plan the high-level design – just sufficiently enough to avert these sorts of issues – before construction begins. The aim should be to start on construction only once we have sufficient confidence that the high-level design will support both the known and unknown requirements of the software.

Happily, much of the high-level design of most software systems can be determined from the business domain in which the software operates. Simply by identifying and understanding the business domain, we can often identify suitable architectural styles and technology stacks that fit well with the typical requirements you would expect of that domain. We don't necessarily even need to know all the requirements of the particular problem space of the software – the problems the software is intended to solve within its business domain. Often, it's enough just to understand the business context to come up with some initial ideas – if a little fuzzy – about the high-level design.

For most types of software projects it will be desirable to front-load the software construction phase with a *discovery* phase consisting of high-level requirements gathering and analysis, and big-picture solution design.

This is normal. Most software systems go through distinct phases of discovery, construction, and maintenance over the course of their life spans. Within each phase of its life, a typical software system will benefit from different approaches – different ways of working – to its development. The iterative and incremental development model, described in the previous section, tends to work best within the construction phase and only once the high-level design is reasonably established and stable. The discovery phase, on the other hand, tends to benefit from more traditional approaches to requirements gathering and high-level design.

The objective of the discovery phase is to learn about the business domain and the specific problems we're being asked to solve within that domain. This process typically involves gathering requirements from relevant stakeholders, researching existing solutions (perhaps reverse engineering legacy systems or studying competitor products), and generally learning as much as we can about the context in which the software will be used.

Early requirements gathering tends to focus on *functional requirements*, but equally important are the *non-functional requirements* (NFRs) – also known as the *performance requirements* – of the software. These are things like security, availability, reliability, accessibility, extensibility, portability, and lots of other "ilities". In many cases these requirements can be inferred from the business domain. For example, a financial trading platform would be expected to prioritize things like security, low latency, and high throughput – that would be obvious if you knew a little about how financial trading happens in the real world.

Non-functional requirements tend to have a very significant impact on the high-level design of software systems. That's because non-functional requirements are *cross-cutting concerns*. A requirement like security cannot be implemented in a single modular component of the software, but rather it is a requirement that must be addressed in _all_ components – it cuts through the whole system design.

Because of their cross-cutting nature, the performance attributes of a system can be hard to change later. It can be difficult, for example, to retrofit particular security standards into a system that wasn't designed with those requirements in mind from the start. Similarly, it can be hard to get a system to scale, for example to handle unexpected spikes in load, if this eventuality was never planned for.

For this reason, early requirements gathering should focus on the non-functional performance requirements – _how_ well the software is required to work – rather than the functional ones – _what_ the software will do. This can feel counter-intuitive. But it tends to lead to better outcomes.

Once we've done sufficient requirements gathering to have a good understanding of the business domain and problem space we're working in, we can start to establish the high-level design. This typically involves exploring various architectural styles and technology stacks, evaluating their suitability for the business domain and problem space. We might do things like *domain modeling* to identify the key entities and relationships in the business domain, so we can map this to software components in our design. Or we might create *architectural diagrams*, for example showing the main software components and their interactions, to create visual representation of the proposed solutions.

We might even develop working *prototypes* to road test different options. This can be a particularly effective strategy for reducing risk and uncertainty in software projects. Sometimes the best way to evaluate a design option is to build a small-scale version of it and see how it performs in practice.

There's a lot of nuance in software design. We make lots of delicate trade-offs in every small component we construct. It is impossible to judge all those trade-offs up-front, prior to construction. Always some requirements and trade-offs will emerge through construction and use of the software. Rapid prototyping allows us to *shift left* in a project the discovery of these hidden requirements and trade-offs.

Some amount of up-front requirements gathering and solution design, done before construction begins, is always useful because it reduces the risks of needing to make expensive pivots later. The objective of producing a high-level design, derived from an understanding of the business domain and problem space, is to create a robust foundation for the software, one that makes it easier for us to adapt to changing requirements later.

Doing high-level design work up-front is not incompatible with the principle of embracing change. On the contrary, it is often necessary groundwork that we need to do to build changeability into a system.

Of course, big up-front design and discovery will not be suitable for every type of software project. These are general principles of software development, not universal ones. Highly innovative projects, in which new problem spaces are invented, typically require significant experimental development work _before_ the problem space and the project requirements emerge. You cannot expect to devise the high-level system architecture ahead of construction in this context. But most software projects can leverage established architectural styles and technology stacks that are already proven to work well in their business domain.

The choice of _how much_ up-front requirements gathering and design work is appropriate will vary from project to project. Too little, and we risk doing lots of expensive rework to accommodate changing requirements later. Too much, and we have the same problem because the system design and delivery plan may be too rigid to accommodate changes.

The objective of the project discovery phase is to do _just enough_ requirements gathering and high-level design up-front that we can be confident that the problem space is well-defined with clear boundaries (without being complete), and that the proposed solution architecture will support evolving requirements within the scope of that problem space.

What's the right amount of discovery work? Experience and intuition are the only guides you have here. But, for most software projects, the emphasis should be on _shallow but wide_, not _deep_, exploration of the business domain and problem space. For example, it will probably be desirable to understand the key components that will be needed in the software, and the interactions between them, but you probably don't need to know exactly how all those components will work or what data will be shared through the interfaces between them. The focus should be on the design decisions that will be hard to change later. Leave the low-level details to be worked out through just-in-time decision-making when the software is being constructed in cycles of iterative and incremental development.

The right balance between discovery and construction will vary from project to project. *Big design up-front*, in which early requirements specifications and solutions designs are worked out at depth, tends to be favoured in *high integrity* and *life critical* software like medical devices and aircraft systems. It can be beneficial, too, in well-understand domains, or otherwise in projects with known and stable requirements – such as replatforming projects in which a legacy system is fully replaced by a new one with like-for-like functionality.

Comprehensive discovery phases can have all sorts of other benefits, too, such as: easier planning and coordination of work between multiple teams, suporting parallel development and faster overall delivery; early identification of major technical challenges and potential blockers; better risk analysis, and easier compliance with industry standards and regulatory requirements; and more accurate cost estimates.

***

If our high-level design fits the problem space well, we should not expect to need to change it significantly later. Unless, of course, the problem space itself changes. But we should not expect that to happen. It is perfectly reasonable for us to expect the problem space of a software system to remain consistent for the life span of that system. We should not expect to be able to pivot from developing a windowing system to an operating system shell, for example – not without throwing away everything and starting over. These are entirely different problem spaces, and so the solutions require entirely different architectural styles, different technology stacks, different construction methods, different testing tools, and so on. They're different products in every way, except for the fact they're both software products.

When we refer to software changeability, we mean the ability to change a software system _within its existing problem space_. The problem space is the domain of the software, or the context in which the software operates. It defines the boundaries of what the software is intended to do.

Evolutionary design should be mostly constrained to lower-level changes – the *low-level design*. As the requirements for a software system evolve, we should be able to easily reconfigure, add, remove, and replace components that sit within the high-level design to meet those changing requirements. It is a requirement of the high-level design to support changes to the components within it.

A good high-level design will also incorporate plans for scaling the software in the future, if needed. For example, a system design may support horizontal scaling by making it relatively easy to extract services, so evolving a modular monolith into something more like microservices. You don't need to prematurely optimize for high-scale from the start, you just need to have a plan for how to get there if you needed to.

Good modularity, clear interfaces, and well-defined communication patterns are all essential for this. These qualities are just as important in monoliths as they are in distributed systems. The advantage of starting with a monolith is that you can more quickly iterate on the high-level design – changing module boundaries, data structures, and communication patterns – than you could if you started with a distributed solution. As soon as you start extracting services, you are committing to a high-level design that is hard to change later.

= Optimize for learning through fast feedback loops

[quote, Jeff Bezos]
____
Success can come through iteration: invent, launch, reinvent, relaunch, start
over, rinse, repeat, again and again.
____

Software development is primarily a learning process. First, we need to learn about the business domain and the problem we're trying to solve within it. Then, through an incremental product development process, we iterate the solution by delivering small changes to users as quickly as possible, learning from the feedback that those users provide, and adjusting our plans for subsequent increments in response to that feedback.

We're also continuously learning from our own experience of building the software. For example, what design patterns are proving to be the most effective at supporting change?

It follows that we should optimize our software development process for learning. We do this by building in lots and lots of feedback loops.

We can optimize our development process by increasing the frequency of feedback. By keeping feedback loops short and fast, so the effect is continuous learning, we can make better decisions, iterate designs more effectively, and reduce wasted effort on low-value development work.

The most important feedback loops are those that come from the users of the software. We can shorten the time it takes to get feedback from users by increasing our release cadence. The objective should be to deliver software updates to users as continuously as possible. This requires investment in methods and tools such as canary and beta release channels, blue-green deployments, A/B testing, and feature flags. Test automation, continuous integration and delivery (CI/CD) pipelines, and comprehensive monitoring also reduce friction, costs, and risks in the process of shipping software updates.

Another way we can optimize our development process for learning is to diversify the types of feedback loops we use. Different types of feedback loops provide different insights. Code reviews and pair programming provide feedback on code quality (maintainability, changeability). Automated tests provide feedback on the correctness and stability of the software. Monitoring systems and analytics data provide feedback on performance and reliability. Retrospectives and post-mortems provide feedback on the development process itself. Different types of feedback loops provide different insights.

There should be multiple feedback loops from the product's users to its developers. User feedback should be a mix of manual qualitative analysis (eg. user interviews and usability testing) and automated quantitative analysis (eg. usage analytics and A/B testing). Most user feedback should be driven by questions we want to answer, or hypotheses we want to test. How are users interacting with the software? What are their pain points? What features are they finding most valuable? What features are they not using? What features do they want that we haven't built yet? User feedback can also be open-ended; customer support tickets, user forums, and social media are all good sources of unsolicited user feedback.

Software that is designed to change is not only easy to modify and extend, but it also has built-in feedback loops. For example, integrated monitoring systems generate usage analytics data, and feature flags allow us to run experiments â€“ to try out new ideas quickly and cheaply. Taken to extremes, fully automated delivery pipelines support continuous deployment, in which mere hours pass between code changes being committed and those changes existing in a production or production-like environment. The faster we can get our code changes into the hands of users, the less likely we are to waste time and money building features that those users don't want or need.

All of these feedback loops allow us to make data-driven decisions about the direction of the software's development, to iterate its design more effectively, and to iterate the design of the workflows that support its development.

Continuous learning through fast feedback is the foundation for building agility into the software development process. To be "agile" in software development means to be able to respond quickly and effectively to change.

= TS-X GitHub Actions Standards
:toc: macro
:toc-title: Contents

toc::[]


This document serves as a collection of best practices for using (and making)
GitHub Actions.

== YAML syntax

////
TODO: Link to YAML best practices
////

=== Readability

Actions and workflows are defined in YAML files. YAML is designed to be a
human-readable, as well as a machine-parsable, data serialization format. YAML
files SHOULD, therefore, be written primarily with readability in mind.

Consideration should also be given to the maintenance of the YAML files. Give
thought, for example, to how diffs will be presented in source control and
pull request systems. As Git is a line-based version control system, it is
best practice to use YAML's multi-line syntax for lists. Instead of:

[source,yaml]
----
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
----

This is better:

[source,yaml]
----
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
----

=== Inline documentation

YAML comment syntax SHOULD be used to document anything that is not intuitively
understood from the YAML data structure.

== Workflows

=== Runners

It is recommended to pin workflows to specific runner versions, such as
`ubuntu-22.04` rather than `ubuntu-latest`. This means you must manually
update workflow configurations when old runner versions are deprecated,
but the benefit is your workflows will be more stable in the meantime.

[source,yaml]
----
# Prefer:
runs-on: ubuntu-22.04

# To:
runs-on: ubuntu-latest
----

=== Expressions

Expressions are commonly used in `if` attributes to make execution of an
individual step or a whole job conditional.

[source,yaml]
----
jobs:
  production-deploy:
    if: github.repository == 'owner/repo' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install -g bats
----

The value of the `if` attribute is treated as a JavaScript expression, rather
than a string value. Expressions can be used in other attributes, which assume
string values by default, using the `${{ <expression> }}` notation. Even in
`if` values, if the expression starts with `!`, the whole expression MUST be
encapsulated in the `${{ }}` syntax, or escaped with `''`, `""`, or `()`.
That's because the exclamation mark is reserved notation in YAML.

For consistency, it is RECOMMENDED this syntax be used to wrap all expressions,
even those in `if` values where this syntax is not required.

[source,yaml]
----
jobs:
  production-deploy:
    if: ${{ github.repository == 'owner/repo' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm install -g bats
----

== Performance

=== Minimalism

Keep actions minimal. The more time an action takes to set up and run, the
higher the costs of running your CI/CD infrastructure. Even shaving a few
seconds off the run of a workflow can add up to significant cost savings over
a month, a year.

Prefer lightweight actions over heavyweight ones. Prefer composite actions
consisting shell scripts over JavaScript actions, and prefer JavaScript
actions over container actions. Where container actions are essential – for
example where you require a specific programming language or toolchain –
prefer to use light images, such as alpine or alpine-node, over heavy ones.

Don't install unnecessary dependencies.

=== Caching

Be sure to use caching features wherever possible. Have package managers
cache dependencies, and cache any generated artifacts that can be reused
between runs or shared between jobs.

=== Timeouts

By default, GitHub kills jobs after 6 hours if they have not finished by
then. Many jobs don't need nearly as much time to finish, but sometimes
jobs can hang and the run consumes unnecessary minutes, which has a
cost.

Therefore it is recommended to specify shorter timeouts that are appropriate
for each job.

This is specified in minutes via the `jobs.<job_id>.timeout-minutes` attribute.
Example:

[source,yaml]
----
jobs:
  set_config:
    timeout-minutes: 30
    runs-on: ubuntu-latest
    steps:
      - [...]
----

=== Concurrency

It is RECOMMENDED to implement a concurrency strategy for workflows, especially
long-running, resource-intensive ones. This will cancel running workflows in the
same group when an event triggers a new run of the same workflow. For example,
you can automatically cancel intermediate builds on a PR when a newer commit
has been pushed to the PR's branch since the build run started.

[source,yaml]
----
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}
----

See the GitHub Docs for further guidance:
https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#concurrency

== Security

See also GitHub's Security Hardening for GitHub Actions guide:
https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions

=== Secrets

Never hard-code secrets in workflow files, even if those files are committed
to private repositories. All sensitive data MUST be managed via GitHub Secrets.

=== Restricting permissions

By default the workflow token, `GITHUB_TOKEN`, which is automatically generated
on each run, is given wide-ranging permissions to GitHub resources and
operations. The principle of least privilege should be applied to these tokens,
which means restricting permissions to the minimum required for the job.

Permissions SHOULD be explicitly restricted on a per-workflow basis using
the `permissions` attribute.

[source,yaml]
----
name: Open new issue
on: workflow_dispatch

jobs:
  open-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - run: |
          gh issue --repo ${{ github.repository }} \
            create --title "Issue title" --body "Issue body"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
----

See the GitHub Docs for a full list of available permissions:
https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#permissions

=== Consuming open source actions

There are many open source GitHub Actions that can be plugged in to your own
workflows. However, just like with any open source software, open source actions
MUST be carefully audited before integrating them into your development
toolchain. The risks are similar to using package managers to automate the
integration of third party components into your applications.

The following steps are RECOMMENDED when using third-party actions:

* Use only actions that are actively maintained. Check that bugs are triaged
  and fixed, and that security vulnerabilities are patched, quickly.

* Use only actions that are published to the GitHub Marketplace, and only actions
  that have been verified by GitHub.

* Review the action's `action.yml` file for inputs and outputs, and check that
  the code does what it says it does.

* Include a specific version of the action, which you have audited. Best practice
  is to specify a commit SHA, rather than a branch or version tag. This ensures
  that the action's code is locked down and cannot be changed without you
  explicitly updating the version reference in your workflow configuration.

[source,yaml]
----
- name: Checkout code
  uses: actions/checkout@a12a3943b4bdde767164f792f33f40b04645d846
----

=== Self-hosted runners

Use self-hosted runners only for workflows in private repositories. Actions
that `runs-on` self-hosted runners MUST also be kept private.

This is because third parties could run malicious code on your self-hosted
runners by forking the public repository and then creating a pull request
that executes the code in a workflow.

This is not an issue with GitHub-hosted runners because those always run in
clean, isolated virtual machines, each instance being destroyed at the end
of a job run. Self-hosted runners may persist environments between jobs,
posing security risks for the machine and its network if the workflow code
cannot always be trusted.

[NOTE]
======
GitHub doesn't allow individual accounts to use self-hosted runners on public
repositories, but they do allow organizations to do so.
======


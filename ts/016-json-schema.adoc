= TS-16: JSON Schema
:toc: macro
:toc-title: Contents

This technical standard sets out some guidelines for JSON schema. The emphasis on this technical standard is on _designing_ JSON schema, though there is also some information on using published JSON schemas such as JSON-LD.

JSON Schema provides a vocabulary for describing the structure of JSON data. Documentation, code, and other artifacts can be generated from JSON Schema definitions, but the primary use case if to validate JSON documents.

JSON schema is commonly used to define the structure of data transferred between systems via network APIs. It may also be used for input validation, to define interfaces for data structures constructed at runtime, and to define data persistence schema (eg. document stores).

toc::[]

== Versions

JSON Schema was originally defined as an http://tools.ietf.org/html/draft-zyp-json-schema-04[IETF standard], but is now maintained as a https://json-schema.org/[community project]. Versions 00 through 04 were published as IETF drafts, while draft-05 moved to the community project.

The current version of JSON Schema is `Draft 2020-12`. It is RECOMMENDED to use this version for new projects. The metaschema for this version is `https://json-schema.org/draft/2020-12/schema`.

== Cross-references

JSON Schema defines a https://www.learnjsonschema.com/2020-12/core/ref/[`$ref`] keyword to link schema from other schema.

.Example
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Locale",
  "description": "Locale, composed from a BCP-47 language tag, ISO-3166 alpha-2 country code, and Olsen IANA timezone ID.",
  "type": "object",
  "required": [
    "country_code",
    "language"
  ],
  "properties": {
    "country_code": {
      "$ref": "country-code.schema.json"
    },
    "language": {
      "$ref": "language-code.schema.json"
    },
    "timezone": {
      "$ref": "timezone.schema.json"
    }
  }
}

----

As per the JSON Schema documentation, it is RECOMMENDED to not require client applications to automatically resolve schema that are referenced from other schema via the `$ref` attribute. Instead, it is RECOMMENDED that JSON Schema publishers automatically swap `$ref` properties for inline schema, using a build step.

A https://github.com/sourcemeta/jsonschema/blob/main/docs/bundle.markdown[command-line tool] is available to do this.

== JSON Hyper-Schema

https://json-schema.org/specification/json-hyper-schema[JSON Hyper-Schema] is an extension to JSON Schema that adds properties to allow the embedding of hypermedia links in JSON documents. It builds on https://datatracker.ietf.org/doc/html/rfc6570[URI Templates (RFC 6570)] and other standards. 

The main use case for JSON Hyper-Schema is to embed hypermedia controls in JSON documents that enable APIs to be navigated, and explored in a dynamic way (ie. without clients necessarily having initial knowledge of all available resources and endpoints).

The following example, taken from the specification, adds a single link:

[source,json]
----
{
  "type": "object",
  "properties": {
    "id": {
      "type": "number",
      "readOnly": true
    }
  },
  "links": [
    {
      "rel": "self",
      "href": "thing/{id}"
    }
  ]
}
----

JSON Hyper-Schema adds the `links` property, which must be an array of "link description objects" (LDO).

Any IANA-registered link relation type can be used to define the link relation type (`rel`). This defines the semantics of the link in terms of its relationship to the resource. The table below describes some of the most commonly used link relation types.

|===
|Type |Description

|`self`
|Identifies the resource itself.

|`next`/`prev`
|Indicates the next or previous resource in a sequence, eg. in a paginated list.

|`first`/`last`
|Refers to the first or last resource in a sequence.

|`up`
|Refers to a parent resource in a hierarchy of resources.
|===

It is RECOMMENDED to use a small subset of link relation types, and to use them consistently across all endpoints in a hypermedia API. You SHOULD NOT define custom relations, unless absolutely necessary when no standard ones fit the use case.

The following best practices also apply for JSON Hyper-Schema:

* Each response should contain minimal links, just enough for clients to navigate deeper.
* Do not expose an entire API graph in any single response, except for simple APIs composed of just a few endpoints.
* It is RECOMMENDED to always include "self" links to the current resource, wherever relevant.
* Use simple, minimalist URI templates, with only necessary path parameters (variables).
* Provide all required template variables in the response object.
* Use `templatePointers` to clearly map data to template variables.
* Use `targetSchema` to describe expected response formats.
* Use `targetHints` for media types and methods.
* Add `title` properties for human-readable link descriptions.

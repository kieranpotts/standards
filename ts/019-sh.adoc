= TS-19: Unix Shells
:toc: macro
:toc-title: Contents

This technical standard covers best practices for writing Unix shell scripts for the purposes of system administration, batch processing, and other low-level automation tasks. See also link:./019a-bash.adoc[TS-19a: Bash] for extended technical standards for the Bash shell specifically.

toc::[]

== Use cases

Shell scripting SHOULD be used only for small utilities and simple wrapper scripts – basic automation tasks, in other words.

If the script is mostly calling other utilities, and if its doing very little data manipulation or complex logic, then shell is probably a good technology choice for the problem.

However, if performance matters, there will probably be more optimum technology choices. Likewise, if the logic includes any non-trivial control flows or if data integrity is paramount, then it may well be better to use a more structured programming language.

== Portability

When writing shell scripts, it is important to consider the target environment, and the particular Unix shell that will be available to execute the script in that environment.

If in doubt, Bash – the "Bourne Again Shell" – is a good choice. It is widely available: it is the most common shell implementation in Linux; it's bundled with macOS (though it's no longer the default shell there); and versions are even available for Windows (Git Bash, WSL, etc.). In addition, Bash has many customizations that make it particularly suitable for complex scripting – things like `local` variables.

But, if portability between different Unix shells is a requirement – for example, if you do not control in which environments a script will be run – then it is best to stick to POSIX-compliant features and avoid shell-specific extensions.

Many Unix shells have a "POSIX mode" that allows you to test a script's POSIX compliance by disabling the shell's non-POSIX features when the script is run. For example, Bash can be run in POSIX-mode using the commands `sh` or `bash --posix`. Alternatively, the following shebang can be added to the top of scripts to trip Bash into running them in POSIX-mode:

----
#!/bin/env sh
----

The following shebang will also tell Bash (and other shells) to run in POSIX-mode. However, this version is a little less portable, because it depends on the path to the `sh` executable being consistent in each runtime environment. The version above will instead lookup the `sh` executable in a wider range of paths.

----
#!/bin/sh
----

Scripts that use either of these shebangs MUST NOT contain Bashisms – like `local` variables – or other shell-specific syntax or built-ins. A linter MUST but used to identify POSIX compliance issues; https://www.shellcheck.net/[ShellCheck] IS RECOMMENDED for this purpose.

[TIP]
======
Dylan Araps's https://github.com/dylanaraps/pure-sh-bible[Pure SH bible] is an invaluable reference resource for writing POSIX-compliant shell scripts.
======

=== Built-ins versus external commands

Whatever the choice of target shell, prefer to write scripts that invoke the shell's built-ins rather than external commands. For example, for simple text manipulation prefer to use the shell's built-in parameter expansion functions rather than external commands like `sed` or `awk`.

Scripts that rely on external commands are less portable, because those commands may not be available in all deployment environments. Scripts that call external commands _may_ be slower too, because external utility programs are executed as separate processes (whereas built-in commands are run in the shell's process).

But often the use of external commands is unavoidable, especially for more complex tasks that require, for example, advanced text processing or system interaction. Where external commands are needed, prefer to use commands that are specified by the POSIX standard; these commands are (almost) guaranteed to be available in all Unix and Unix-like systems. Standard Unix utilities are listed in the https://pubs.opengroup.org/onlinepubs/9699919799/utilities/[POSIX Shell and Utilities specification].

[TIP]
======
You can check whether a command is a shell built-in or an external command by typing:

----
type <command>
----

Example:

----
$ type rm
rm is /bin/rm
----

This output shows that `rm` is an external command, not a shell built-in.
======

All other dependencies – where a "dependency" is anything that is not part of the target shell language – SHOULD be documented, either in a file-level comment at the top of the script, or in an accompanying README.

=== Options

It is RECOMMENDED to use `set` at the top of scripts to set shell options, so that calling the script using `sh <script-name>` does not break its functionality.

== Execution and permissions

Scripts that are intended to be executed directly MUST be executable. This is achieved by setting the executable bit on the script file: `chmod +x <script-name>`.

Libraries – shell scripts that are intended only to be sourced by other scripts – SHOULD NOT be executable. This is achieved by removing the executable bit on the script file: `chmod -x <script-name>`.

SUID and SGID MUST NOT be applied to _any_ shell scripts, whether or not those scripts are executed directly. These permissions open up potential vulnerabilities. Programs with SUID (Set User ID) are run with the elevated permissions of the file owner, so increasing risk if the scripts are exploitable. And SGID (Set Group ID), when applied to a file, executes the file with the group permissions of the file rather than the user's current group. SGID is used to give group access to executables, but it can lead to unintended access if those groups are not managed carefully.

[source,sh]
----
# In the below output, the `s` in the `rws` bit shows that
# SUID is set on the user (owner) permission.
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root ...

# In the below output, the `s` in the group section (`rws`)
# shows that SGID is set on the directory.
ls -ld shared_folder
drwxrwsr-x 2 alice devteam ...
----

Use the following commands to unset SUID and SGID from shell scripts:

[source,sh]
----
# Remove SUID.
chmod u-s filename

# Remove SGID.
chmod g-s filename
----

== General code style

For legacy code, stay faithful to the existing prevailing code conventions. The following guidelines apply to new shell scripts.

=== Source order

The source code for shell scripts SHOULD follow this order:

1. Shebang line
2. File-level comments
3. Variables
4. Functions
5. Main program

Keep all custom functions together in one block. Try to avoid hiding executable code between functions. It makes the code hard to follow.

This structure also provides a useful framework for decomposing large scripts into smaller, more manageable files.

[source,sh]
----
#!/bin/env sh

# File description here.
# Copyright: <Legal Name>
# License: MIT

. variables.sh
. functions.sh

main "$@"
----

For libraries – ie. shell scripts that are intended only for sourcing into other scripts, rather than direct execution – the shebang line is optional but RECOMMENDED. Including the shebang in all shell scripts, including sourced ones, provides clarity over which shell the script targets for compatibility.

=== main()

For complex scripts – anything more than a couple of hundred lines, or anything with non-linear control flows – it is RECOMMENDED to define a function called `main` that will be the main entry point for the program. This SHOULD be the first function defined, but it should be called last, at the very end of the script.

Thus, the very last line in a shell script SHOULD be a call to the `main` function. Arguments passed to the script SHOULD, normally, be forwarded to the main function.

[source,sh]
----
main "$@"
----

=== Indentation

Use two spaces. Never use tabs for indentation.

The only exception for use of tabs is in tab-indented here-documents, ie. in the body of `<<-`.

=== Blank lines

Insert blank lines between discrete blocks of code, to improve readability.

=== Line length

Most code lines – except literal strings that can't be wrapped – SHOULD be kept under 80 characters in length.

It is RECOMMENDED to use continuation lines to break up long commands, expressions, and other statements that would otherwise exceed the line length limit.

[source,sh]
----
command1 \
    && command2 \
    && command3
----

Continuation lines MUST be indented to show that they are continuations of the preceding line. It is RECOMMENDED to use double indentation – four spaces – for continuation lines.

Expressions SHOULD be broken _before_, not _after_.

Pipelines are another good use case for continuation lines. Put the pipe symbol followed by the next command in the chain on a new line. Comments will need to precede the whole pipeline. If the pipeline is complex, and individual commands within it require extensive explanation, extract those commands into separate functions and use function-level comments to capture the information.

[source,bash]
----
# Comment for the whole pipeline.
command1 \
    | command2 \
    | command3 \
    | command4
----

Code lines MAY be longer than 80 characters where breaking the line decreases readability.

=== Naming conventions

Generally, err on the side of clarity over brevity. Do not truncate or abbreviate the names of things where doing so would decrease understandability of the code.

The names of all things – functions, variables, etc. – SHOULD be descriptive in the places in which those things are _used_, not only in the places where they are _defined_. This means you can't rely on adjacent comments to document the meaning of things where they are declared, because those names will appear in other code contexts where those descriptions are not present.

==== File names

Shell scripts SHOULD be named with all-lowercase ASCII letters, with words delimited by hyphens.

The `.sh` extension MAY be omitted for files that are intended to be executed like binaries. The `.sh` extension SHOULD be kept for shell libraries – ie. files that are intended to be sourced by other shell scripts, or be executed by other build tools such as `make`.

Thus, the omission of the `.sh` extension informs users that the script is intended to be directly executed as a command: `./<script-name> <arg1> <arg2> ...`.

==== Variable names

The names of variables should be composed from lowercase ASCII letters only, with underscores used to delimit words. Numbers (0-9) MAY be used in variable names in appropriate scenarios.

A common convention is to use UPPER_SNAKE_CASE for variable names. This is bad practice. Using this naming convention risks collisions with shell-defined variables and environment variables.

*Constants* – which are declared with the `readonly` keyword – also SHOULD NOT be capitalized. This too is a common convention, but it is bad practice for the same reason.

[source,sh]
----
# ❌
readonly PATH_TO_FILES='/some/path'

# ✅
readonly path_to_files='/some/path'
----

The only exception to this naming convention is for variables exported to the environment – ie. environment variables that will be made available to all child processes spawned from the current shell. These SHOULD be capitalized, following the prevailing conventions for Unix environment variables. Environment variables are, after all, intended for use by other scripts and programs, to it is best to stick with the community's naming conventions here.

.Examples
[source,sh]
----
declare -xr ORACLE_SID='PROD'
export PATH="/usr/local/bin:$PATH"
----

Consider using a vendor-specific prefix for all the variables your scripts export to the environment. This helps to reduce the likelihood of collisions with environment variables set by other scripts and programs, or even by the shell itself.

*Arrays* SHOULD be pluralized. In loops, the singular form of the array name SHOULD be used for the iteration variable.

[source,sh]
----
for zone in "${zones}"; do
  # Do something with "${zone}".
done
----

==== Function names

Functions SHOULD follow the same naming convention as for variables; that is, function names SHOULD be composed from lowercase ASCII letters with underscores used to delimit words.

Functions that are part of the public interface of a package SHOULD be namespaced. It is RECOMMENDED to use the following naming convention for this purpose.

----
<package_name>::<function_name>
----

.Example
[source,sh]
----
my_pkg::my_func() {
  # ...
}
----

== Variables

Most variables in a script SHOULD be designed to be constants, which means their values SHOULD NOT change after being assigned the first time. Err on the side of writing new variables, rather than overwriting existing ones, whenever you need to store a new value in memory. Scripts that follow this design principle tend to be a bit more robust and easier to understand and debug.

Variables MUST be declared `readonly` unless they are required to be writable by the business logic. The `readonly` attribute SHOULD be applied immediately after the variable declaration. Alternatively, use `declare -r` to declare a variable and set its `readonly` attribute immediately. This improves the robustness of scripts by preventing the overwriting/reassignment of variables that are not intended to be changed.

[source,sh]
----
zip_version=$(dpkg --status zip | grep 'Version:' | cut -d ' ' -f 2)

if [ -z "${zip_version}" ]; then
  # Error handling here.
  exit "${error_code}"
else
  readonly zip_version
fi
----

=== Bracket syntax

Most variable references SHOULD use the bracketed syntax, `${var}`, over the unbracketed one, `$var`. The bracketed syntax is more readable, more, robust, and more flexible. Because the brackets clearly delimit the variable name, it is easier to identify the variable names, and it helps to avoid ambiguity in complex expressions. It also makes it easier to concatenate with other variables or literal string values, eg. `${var}bar`.

[source,sh]
----
var="foo"

# Looks for a variable named 'varbar' (likely undefined).
echo "$varbar"

# Correctly expands to 'foobar'.
echo "${var}bar"
----

In addition, the bracketed syntax can be extended to query and manipulate values returned from variable substitution. For example, `${#var}` returns the length of a string value, `${var:0:1}` returns the first character of the value, and so on. It is also possible to provide default (fallback) values.

However, the brackets MAY be omitted from positional parameters – `$1`, `$@`, etc. – and other special variables.

=== Quotes and variable expansion

For variable assignment, almost all values SHOULD be quoted. There are some exceptions:

[source,sh]
----
# Quote most values on assignment for consistency, even if not required.
flag="on"

# Literal integers that will be used in mathematical expressions MAY be unquoted.
val=42

# Quote command substitutions, even when you expect the output to
# be an integer. Use single quotes for literal arguments passed to
# the command..
result="$(some_command 'arg1' 'arg2')"

# The following two statements are equivalent. In both cases, the value `true`
# is a string. Shell script do not have a boolean type, but it is convention to
# use the string values "true" and "false" to represent boolean values. However,
# this may not be obvious to novice shell programmers, so better to be explicit
# and include the quotes.
bool="true" # ✅
bool=true   # ❌
----

Variable references SHOULD be quoted in almost all cases, even if the values are things like commands or path names. This prevents word splitting and globbing issues.

Double quotes SHOULD be used in almost all cases. Single quotes MUST be used only where you explicitly want to disable substitution.

[source,sh]
----
# ❌ SHOULD NOT do this for string values, unless variable expansion is intended:
echo ${var}

# ✅ RECOMMENDED in almost all cases:
echo "${var}"
----

The risk of not quoting variables is demonstrated by the following code example.

[source,bash]
----
filename="My File.txt"

rm ${filename}    # Interpreted as: `rm My File.txt`   → error
rm "${filename}"  # Interpreted as: `rm "My File.txt"` → correct
----

Where variable expansion is required, the variable reference MUST NOT be quoted, and an adjacent comment MUST explain why the variable is being allowed to expand.

[source,sh]
----
# Expand $vars into arguments.
some_command ${vars}
----

=== Positional parameters

Positional parameters are the arguments passed to a script or function. They are accessed using the `$1`, `$2`, etc. syntax.

It is RECOMMENDED to provide default values for positional parameters.

When you want to pass on _all_ parameters, say from the script to a `main()` function, you probably want to use `"$@"` (quoted). This will forward all arguments as-is. By comparison, both `$@` and `$*` (unquoted) will split on spaces, clobbering arguments that contain spaces and dropping empty-string arguments. `"$*"` (quoted) is probably not what you want either; it will expand to just one string argument, with words in the value concatenated by spaces.

[IMPORTANT]
======
*Always validate user input variables.*  This rule applies equally to input to scripts and input to functions within a script. Be defensive in _all_ your code.
======

=== Command substitution

Prefer the newer syntax, `var=$(command)`, over the older backtick syntax, `var=`command``. The reason is that nested backticks require escaping with `\`, reducing readability of the command statement.

[source,sh]
----
# ✅
var="$(command "$(command1)")"

# ❌
var="`command \`command1\``"
----

However, both work in all modern POSIX-compliant shells. It is okay to maintain the older syntax in legacy scripts.

== Functions

=== Function declarations

For POSIX-compliant scripts, the `function` keyword cannot be used in function declarations.

[source,sh]
----
# ✅
my_func() {
  # ...
}

# ❌
function my_func() {
  # ...
}
----

It is RECOMMENDED to exclude the `function` keyword even where it is supported by the target shell. It does not add any value, only clutter.

Braces MUST be on the same line as the function name, with no space between the function name and the opening parentheses, and with no space between the opening and closing parentheses.

The opening curly brace SHOULD also be on the declaration line, preceded by a single space character.

////

=== Function invocation

// TODO

=== Function bodies

// TODO

////

== Control flow

It is RECOMMENDED to use the syntax in which `; then` and `; do` is written on the end of `if`/`for`/`while`/`until`/`select` statements, rather than on new lines. `else` SHOULD be on a line on its own. And closing statement (`fi` and `done`) SHOULD also be on their own lines, vertically-aligned with the opening statement. This style is more conventional and improves readability.

[source,sh]
----
count=99

# ✅
if [ $count -eq 100 ]; then
  echo "Count is 100"
elif [ $count -gt 100 ]; then
  echo "Count is greater than 100"
else
  echo "Count is less than 100"
fi

# ❌
if [ $count -eq 100 ]
then
  echo "Count is 100"
elif [ $count -gt 100 ]
then
  echo "Count is greater than 100"
else
  echo "Count is less than 100"
fi
----

The inner content of block-level structures, such as conditionals and loops, MUST be indented by two spaces.

The whitespace padding within the square brackets is optional, but including it is RECOMMENDED. It is a common coding convention, and it improves readability.

Conditional blocks may be nested, but this reduces readability and maintainability. Look to refactor complex conditional logic into the flattest possible structure. The `&&` and `||` operators are useful tools here; they can be used to create shorthand conditional statements, executing commands based on the result of preceding commands.

[source,sh]
----
if sudo apt-get update ; then
  sudo apt-get install pyrenamer
fi

# Can be refactored to:
sudo apt-get update && sudo apt-get install pyrenamer
----

Aim for there to be just one level of `if`/`else` conditions. If you needed nested conditions, consider using the shorthand syntax (`&&` and `||` operators), extracting nested logic into functions, or refactoring in other ways.

=== Case statements

Case statements SHOULD be written out as below. The pattern and closing `;;` are each on their own lines at the same indentation level. Nested commands, run when the pattern matches, should be indented one additional level.

[source,sh]
----
case expression in
  case1)
    operation1
  ;;
  case2)
    operation2
    operation3
  ;;
esac
----

However, simple commands may be put on the same line as the pattern and the `;;`, as long as the expression remains readable. Add a space after the closing parenthesis of the pattern and another before the `;;`. This is often appropriate for single-letter option processing.

.Example from Google's Shell Guide
[source,bash]
----
verbose='false'
aflag=''
bflag=''
files=''

while getopts 'abf:v' flag; do
  case "${flag}" in
    a) aflag='true' ;;
    b) bflag='true' ;;
    f) files="${OPTARG}" ;;
    v) verbose='true' ;;
    *) error "Unexpected option ${flag}" ;;
  esac
done
----

In general, there is no need to quote match expressions. Pattern expressions SHOULD NOT be preceded by an open parenthesis.

Avoid the `;&` and `;;&` notations.

== Exit codes

All executable scripts MUST return an exit code. Functions MAY return exit codes, too.

Exit codes are limited to integers between 0 and 255.

Return `0` to represent success. Any non-zero value denotes an error. Use `1` for a general, undocumented error. Use other custom error codes for each handled scenario.

All error codes MUST be documented. They are an important part of the API of a script or function.

In scripts, check the return values from error-prone commands before continuing with the next operation. If the return value is unexpected, `exit` with a custom error code to represent that specific error condition. This is how exceptions are handled in shell scripts.

== Error messages

OPTIONALLY, non-zero exit codes may be accompanied by user-friendly error messages to aid in debugging and user feedback. Error messages MUST BE directed to `stderr`, to keep actual issues separated from normal output.

Error messages SHOULD be prefixed with the name of the script or function that produced the error, to make it easier to identify the source of the error.

It is RECOMMENDED to implement a custom function to standardize error message formatting. Add any other information to error messages that may help with debugging.

.Example from Google's Shell Guide
[source,sh]
----
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit 1
fi
----

== Comments

In higher-level programming languages, the higher abstractions allow programmers to express their design through modules, function and object names, data structures, and other constructs. Instead of relying on comments to explain the code, it is considered best practice to try to design the code in a way that it clearly articulates _what_ it does, without additional annotations. Therefore, in higher-level programming languages, inline comments tend to be used quite sparingly, used to explain only the most complex algorithms, or why certain design patterns where chosen over more obvious ones, and so on.

Lower-level languages, like shells and other scripting languages, provide fewer opportunities to develop self-explanatory code. Indeed, the syntax of lower-level languages can often be cryptic and non-intuitive.

For this reason, it is strongly RECOMMENDED that shell scripts be liberally commented.

Use comments to express in plain English things that are not obvious from the code itself. This is especially important for complex logic, unusual syntax, and other non-obvious constructs.

For shell scripts, it is okay for comments to describe _what_ the code does. This is especially useful to draw attention to the most important bits of business logic. Even for experienced shell programmers, it will often be quicker to read through the comments, rather than read through the code itself, to understand what the code does and how it works.

Remember, *the purpose of comments is to reduce cognitive overhead*. Whatever the language or level of abstraction, add comments where they make things easier to understand, or where you want to communicate important information that cannot be ascertained from the code alone. Remove comments that are superfluous, redundant, or that do not add any tangible value. If in doubt: leave a comment!

=== File-level comments

All shell files should start with one or more lines of comments that provide an overview of the contents and purpose of the script. Include copyright, license and support notices as required for distributed libraries. List dependencies – that is, any commands or programs that the script calls but which are not built-in to the shell and which are not POSIX standards.

[source,sh]
----
#!/bin/env sh

# File description here.
#
# Copyright: <Legal Name>
# License: MIT
#
# Dependencies:
# - <dep1>
# - <dep2>
# - <dep3>
----

=== Function comments

All functions SHOULD be commented - regardless of their length and complexity.

Function comments SHOULD contain:

- A description of the function.
- A list of global variables used (whether or not they are modified).
- Arguments taken.
- Outputs to `stdout` and `stderr`.
- Returned values (ie. exit statuses).

It is not necessary to document anything that is written to `stdout` or `stderr`.

The purpose of function comments is to make it easier for other programmers to use your functions. They should be able to do this by reading simple API documentation, written in English in a consistent structured format, rather than needing to reverse engineer the code in their heads.

.Template
----
# ------------------------------------------------------------------------------
# <Function description.>
#
# @global <var_name> - <Description of the global variable.>
# @global <var_name> - <Description of the global variable.>
#
# @param 1 - <Parameter description.>
# @param 2 - <Parameter description.>
#
# @output stdout - <Description of the output to stdout.>
# @output stderr - <Description of the output to stderr.>
#
# @return void - <Description required for non-void and non-zero return values.>
#
my_func() {
  # ...
}
----

.Example
----
# ------------------------------------------------------------------------------
# Print notification of a successful operation.
#
# @global BOLD - ANSI escape code for bold text.
# @global GREEN - ANSI escape code for green text.
# @global RESET - ANSI escape code to reset text formatting.
#
# @param 1 - Message to print.
#
# @output stdout - Formatted success message.
# @output stderr - None.
#
# @return void
#
print_success() {
  echo -e "${BOLD}${GREEN}[SUCCESS]${RESET} $1"
}
----

The function description – at the top of a function's comment block – MUST be clear about any *side effects* of calling the function that might take a programmer by surprise. Examples of side effects that SHOULD be documented include:

* Changes to the current working directory.
* Changes to the filesystem (eg. create directories, move files, etc.).
* Exiting the process (`exit`).

Printing output to `stdout` and `stderr` is also considered to be a side effect. Document these via the `@output` tags in the function comment block.

=== TODOs

`TODO` comments MAY be included in shell scripts to draw attention to areas that require further development, review, or refactoring.

Use the following convention for TODO comments. The square brackets are OPTIONAL; they reference an issue number in the project's task tracker, if applicable.

----
# TODO: Short description. [#34]
----

If you intend to implement the fix or improvement yourself, you MAY include your unique identifier in brackets adjoining the `TODO` keyword, as below. Use a consistent identifier, so you can easily search for your personal TODOs across a codebase. Your unique identifier may be your email address, GitHub username, etc.

----
# TODO(username): Short description. [#34]
----

[TIP]
======
IDE extensions such as https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree[Todo Tree] can help you to manage code TODOs.
======

== Miscellaneous shell built-ins

This section covers best practices for using various other shell built-ins. Examples of shell built-ins include `echo`, `read`, `set`, and `eval`.

=== eval

Do not use `eval`. It munges the input when used for assignment to variables, and it can set variables without making it possible to check what those variables were.

[source,sh]
----
# What does this set? Did the command `set_my_variables` succeed?
# The script itself cannot answer these questions.
eval $(set_my_variables)
----

== Unix utilities

This section covers best practices for using standard Unix utilities, which are implemented as external commands rather than being built-in to the shell itself, but which are commonly used in shell scripts. Examples of external Unix utilities include `rm`, `ls`, and `grep`.

=== `rm`

Be careful about using *wildcard expansion* of filenames. Consider a directory with the following contents:

----
-f (file)
-r (file)
somedir (dir)
somefile (file)
----

Notice that we have files here named `-f` and `-r`. If you use `*` to expand the filepaths, like this:

[source,sh]
----
# ❌
rm -v *
----

This will delete almost everything in the directory by force, including the `somedir` directory. It is a lot safer to use `/*` for the path expansion:

[source,sh]
----
# ✅
rm -v /*
----

This will remove `somefile` and the `-f` and `-r` files, but it will not delete the subdirectory `somedir`.

''''

== References

* https://google.github.io/styleguide/shell.xml[Google's shell style guide]

* https://github.com/dylanaraps/pure-sh-bible[Pure SH bible] by Dylan Araps

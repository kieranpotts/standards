= TS-19: Unix Shells
:toc: macro
:toc-title: Contents

This technical standard covers best practices for writing Unix shell scripts, which are commonly used for system administration, automating tasks, and doing batch processing. See also link:./019a-bash.adoc[TS-19a: Bash] for extended technical standards for the Bash shell specifically.

toc::[]

== Choice of shells

When writing shell scripts, it is important to consider the target environment and the particular Unix shell that will be available to execute the script in that environment.

If in doubt, the Bourne Again Shell (`bash`) is a good choice, as it is widely available – it is the most common implementation of a Unix shell in Linux distributions, it's bundled with macOS (though not enabled by default), and a version is also available for Windows – and it has many custom features that make it particularly suitable for scripting.

== Portability

If portability between different Unix shells is a requirement, it is best to stick to POSIX-compliant features and avoid shell-specific extensions. For example, Bash's `[[ ... ]]` syntax is not POSIX compliant, and in fact this proprietary syntax has been adopted by other shells but it does not always do the same thing – which could lead to inconsistent behavior if the same script is run in different shells.

Many Unix shells have a "POSIX mode" that allow you to test a script's POSIX compliance by disabling any non-POSIX features of the shell when the script is run. For example, Bash can be run in POSIX using the commands `sh` or `bash --posix`; alternatively, either of the following hashbangs can be added to the top of the script (the second one is a bit less portable).

----
#!/bin/env sh
#!/bin/sh
----

Dylan Araps's https://github.com/dylanaraps/pure-sh-bible[Pure SH bible], a collection of pure-POSIX shell scripts, is an invaluable resource, too.

=== Built-ins versus external commands

Whatever the choice of target shell, prefer to write scripts that invoke shell built-ins rather than separate processes. For example, prefer the use of the shell's built-in parameter expansion functions over external commands like `sed` or `awk` for simple text manipulation tasks.

Scripts that rely on external commands are less portable (because the external commands may not be available in all deployment environments). The scripts will also be less robust (ie. more prone to errors), and they may be less efficient, too.

== Conditionals

Prefer the syntax in which the `then` keyword is placed on the same line as the `if` statement, separated by a semicolon. This style is more conventional and improves readability.

[source,bash]
----
count=99

# ✅
if [ $count -eq 100 ]; then
  echo "Count is 100"
elif [ $count -gt 100 ]; then
  echo "Count is greater than 100"
else
  echo "Count is less than 100"
fi

# ❌
if [ $count -eq 100 ]
then
  echo "Count is 100"
elif [ $count -gt 100 ]
then
  echo "Count is greater than 100"
else
  echo "Count is less than 100"
fi
----

Conditional blocks may be nested, but this reduces readability and maintainability. Look to refactor complex conditional logic into the flattest possible structure. The `&&` and `||` operators are useful tools here; they can be used to create shorthand conditional statement, executing commands based on the result of preceding commands.

[source,bash]
----
if sudo apt-get update ; then
  sudo apt-get install pyrenamer
fi

# Can be refactored to:
sudo apt-get update && sudo apt-get install pyrenamer
----

== eval

Do not use `eval`. It munges the input when used for assignment to variables, and it can set variables without making it possible to check what those variables were.

[source,bash]
----
# What does this set? Did it succeed? In part or whole?
eval $(set_my_variables)

# What happens if one of the returned values has a space in it?
variable="$(eval some_function)"
----

== References

* https://google.github.io/styleguide/shell.xml[Google's shell style guide]

* https://github.com/dylanaraps/pure-sh-bible[Pure SH bible] by Dylan Araps

= TS-10: System Design
:toc: macro
:toc-title: Contents

This technical standard describes general software architectural design best practices and standards.

toc::[]

== Quality attributes

All software systems MUST be designed with the following performance qualities in mind.

Desirable performance qualities are presented here in _approximate_ order of importance, from most important to least important. However, the relative importance of these qualities will vary from one software domain to another.

****
See Richard P Gabriel's essay, https://dreamsongs.com/RiseOfWorseIsBetter.html[The Rise of Worse is Better], for a thoughtful exploration of the relative importance of these qualities in software design.
****

In practice, these qualities are not mutually exclusive. Indeed, in many ways they are mutually reinforcing. For example, the design constraints necessary to make a system fast tend also to result in system designs that are simpler, more consistent, and more fault-tolerant.

=== Correctness

Correctness is the ability of a system to perform its core functions consistently well. The actual behaviors of the system always match the expected behaviors, as specified in the system requirements.

For a system to consistently behave correctly, all possible states – including failure modes – must be predicted and planned for in the system's design. There should be not unhandled edge cases that could trip the system into an invalid state.

*Data integrity* – which means that a system correctly processes and maintains data throughout its lifecycle – is a critical aspect of correctness.

As a general rule-of-thumb, correctness should not be sacrificed for any other quality. For example, it will often be better to deliberately design a system to be a bit slower for some operations, than to speed things up in a way that risks the system entering an invalid state. Better to implement additional validation checks that slow down a write operation, but which ensure that the application state remains consistent and valid.

=== Resilience

Also known as fault tolerance, resilience is the ability of a system to recover from failures, and so continue operating. Network issues, runtime exceptions, and other disruptions and unexpected scenarios are *gracefully handled* by the system.

A system that is resilient is said to have *high availability*.

// TODO: Ways to achieve both high availability *and* correctness -eg. "eventual consistency" strategies.

// TODO: Only a subset of functionality may be highly-available - eg. Monzo.

=== Speed

Fast software changes the behavior of its users. It reduces the cognitive friction involved in using the software, allowing users to stay focused on their tasks, and so to be more productive. Conversely, slow software limits us, perhaps more than most people realize. Think, for example, when was the last time you got any meaningful work done on airplane Wi-Fi?

In order to make things fast, you often have to do complex things behind the scenes. Instagram, for example, optimistically uploads users' photos while they are still typing the captions for them, so the subsequent user-initiated upload operation feels instantaneous.

Fast, reliable software also has a competitive advantage. The perceived speed of Instagram has no doubt played a big role in its success, relative to the many other photo sharing apps that competed in the early days. Fast software subliminally signals quality and reliability to users.

=== Simplicity

Achieving fast software also demands a relentless focus on interface simplicity – ie. the product design from the user's perspective.

Companies that focus on delivering fast software tend also to have very focused products. That's because the effort required to make software fast often requires stripping away non-essential features. Consider, for example, how a streamlined project management tool like Linear loads quickly and has higher overall perceived performance than heavier-weight enterprise applications like, say, Workday.

Simple software signals to the user that you've thought about what _really_ matters to them, and eliminated everything else.

For software to have simple interfaces, perhaps more important than having a small feature footprint is to have a high degree of consistency in the interface design and behavior. Consistency is a key aspect of usability and accessibility. Consistent design and behavior allows users to intuitively predict how the system will behave in different scenarios based on their previous experiences with it.

There is another aspect to simplicity: the internal implementation. Usually, it is more important for the interfaces of software systems to be simple, than for their internal implementations to be simple. But simplicity in the internal implementation is important too.

A system with a simple implementation tends to be easier to maintain and extend than one that is internally quite complex in its structure and data flows. And ultimately this has value to users. A system that is easy to maintain and extend is more likely to satisfy its users' needs over time, as its functionality can be more rapidly iterated, driven by user feedback.

=== Completeness

The quality of completeness is defined here as a system that provides all of the important functions that its target users need or want.

All software – but especially web-based software-as-a-service and other continuously-delivered systems – are perpetual works-in-progress. Modern software systems are continuously evolving, responding to ever-changing requirements. Software can never be "complete", in this sense.

Therefore, rather than aiming for completeness, it is better to target a small critical subset of functionality for the first public release. From that small (and simple) baseline of functionality, the system's capabilities can be incremented, and its design iterated, driven by user feedback.

= TS-13: Code Design
:toc: macro
:toc-title: Contents

This technical standard covers low-level concerns related to the structure and formatting of code. It covers topics such as naming conventions, commenting best practices, and object-oriented design principles.

These guidelines are language-agnostic. This technical standard is intended to be applicable for any general-purpose, high-level programming language (Python, Java, JavaScript, etc.). Some of the content will also be relevant for lower-level languages, such as shell scripting languages like Bash.

For higher-level design concerns, such as architecture and design patterns, see link:./012-application-architecture.adoc[TS-12: Application Architecture] and link:./010-system-design.adoc[TS-10: System Design].

toc::[]

== Abstraction

.Definition of abstraction
[quote, Balzer et al. 1989]
____
Abstraction in programming is the process of identifying common patterns that have systematic variations; an abstraction represents the common pattern and provides a means for specifying which variation to use.

An abstraction facilitates separation of concerns: The implementor of an abstraction can ignore the exact uses or instances of the abstraction, and the user of the abstraction can forget the details of the implementation of the abstraction, so long as the implementation fulfills its intention or specification.
____

Abstraction is a general term that refers to any design pattern that hides complexity. Complex behaviors and/or data are hidden behind some kind of facade, which exposes a simplified interface for interacting with that hidden logic and data. Abstraction is one of the primary ways by which we make complex systems simpler. It is implemented through various mechanisms for *encapsulation*, which are typically provided by the programming language.

One of the effects of abstraction is the *compression* of other parts of the code. Compression refers to complex behavior or logic being represented by less code. Abstraction makes that possible by encapsulating complexity into higher-level constructs – things like functions, classes, objects, modules, packages, subroutines, plugins, macros, and so on.

Abstraction, and the compactness and cleanliness it brings to program code, is widely held up to be a good thing. Abstraction leads to efficiently-expressed logic, reducing cognitive load. Abstraction also facilitates code reuse.

But, like everything in software design, abstraction involves trade-offs. The overuse and misuse of abstraction can create problems, too.

In most types of abstraction, the complexity that is hidden behind the facade – the "common pattern" that is abstracted away – is replaced by an identifier of some kind – a function or class name, say. All that is left in the code is a name that describes all that hidden complexity.

A high-level of abstraction may see a single, seemingly simple, function call hide hundreds, maybe even thousands, of lines of complex logic, important business rules, and/or interactions with other systems.

It follows that, for code to remain understandable, the names given to abstractions is a critical consideration in code design. The names of modules, classes, functions, and variables – all of which are programming language structures from which abstractions are made – SHOULD accurately describe _all_ the important details of the hidden logic and data.

Therefore, abstractions tend to work best when they are small, simple, and focused.

We should be wary of large abstractions. Large abstractions tend to be leaky abstractions. Because they encapsulate a lot of complexity, some of that complexity is inevitably exposed through the public interface of the abstraction (its facade). It tends to be quite hard to change the implementation of leaky abstractions without breaking code that depends on them, because their interfaces are likely to need changing with their implementations.

Rather than layering abstractions on top of abstractions, eg. through deep inheritance hierarchies, it is often better to compose logic from lots of small, shallow abstractions. Erring on the side of *composition over inheritance* tends to lead to code designs that have better evolvability.

A notable exception to this rule is domain modeling in object-oriented programming. In this case, inheritance hierarchies can be quite useful for modeling real-world taxonomies and ontologies. This was the original intent of object-oriented programming, after all. Inheritance tends to work well in this specific context.

== Naming things

Generally, err on the side of clarity over brevity. Do not truncate or abbreviate the names of things where doing so would decrease understandability of the code.

The names of all things – functions, variables, etc. – SHOULD be descriptive in the places in which those things are _used_, not only in the places where they are _defined_. This means you can't rely on adjacent comments to document the meaning of things where they are declared, because those names will appear in other code contexts where those descriptions are not present.

== Comments

In higher-level programming languages, the higher abstractions allow programmers to express their design through modules, function and object names, data structures, and other constructs. Instead of relying on comments to explain the code, it is considered best practice to try to design the code in a way that it clearly articulates _what_ it does, without additional annotations.

Therefore, in higher-level programming languages, inline comments tend to be used quite sparingly, used to explain only the most complex algorithms, or why certain design patterns where chosen over more obvious ones, and so on.

Lower-level languages, like shells and other scripting languages, provide fewer opportunities to develop self-explanatory code. Indeed, the syntax of lower-level languages can often be cryptic and non-intuitive. For this reason, it is strongly RECOMMENDED that things like shell scripts be liberally commented.

Remember, *the purpose of comments is to reduce cognitive overhead*. Whatever the language or level of abstraction, add comments where they make things easier to understand, or where you want to communicate important information that cannot be ascertained from the code alone.

Remove comments that are superfluous, redundant, or that do not add any tangible value.

Removing comments does not necessarily make the code "cleaner". Even if things get messier with comments, this is usually preferable to losing valuable knowledge. Ignore what Uncle Bob says and adopt the view that "comments are mostly good".

_If in doubt: leave a comment!_

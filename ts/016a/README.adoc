= TS-16a: Webhooks
:toc: macro
:toc-title: Contents

This technical standard extends *link:../016/README.adoc[TS-16: HTTP APIs]* with specific guidance on the design of webhooks.

This standard leans heavily on https://www.standardwebhooks.com/[Standard Webhooks], which is a community-driven initiative to document best practices for webhook implementation. Other influential sources are listed in the references section at the end of this document.

Protocols such as WebSockets and Server Sent Events, and other such mechanisms that can be used to push data to clients in real-time, are outside of the scope of this technical standard.

toc::[]

== What are webhooks?

Webhooks, also known as web callbacks or HTTP callbacks, are a design pattern implemented in public web services to handle asynchronous event notifications from upstream services. Webhooks facilitate integrations between web services that are owned and operated by different organizations. Webhooks typically sit alongside regular HTTP APIs, though this is not a requirement.

Webhooks are HTTP API endpoints that receive notifications about interesting things (events) that happened in third-party systems on which the service depends. For example, a service may use various third-parties to process payment card transactions and send SMS messages to its users. Those third-party services may send HTTP messages to the service, via its webhook endpoints, to tell it about events that happened in their systems, like when a payment has been successfully processed or when an SMS message fails.

Webhooks can be thought of as a sort of "reverse API". Rather than clients pulling information from an upstream service, the service pushes information to clients when certain events occur. It is the client, not the server, that implements special HTTP endpoints – which are the actual "webhooks" – to receive event notifications from the server. This can be a more efficient use of computing resources, as it avoids the need for clients to poll upstream services for updates. And it allows for more real-time data synchronization between systems.

=== Relationship to message-driven architecture

Webhooks are a subset of message-driven communication patterns. In the webhooks pattern, event-oriented messages are exchanged via HTTP between systems owned and operated by different parties (ie. inter-organization communication).

*link:../017/README.adoc[TS-17: Messages and Events]* covers best practices for the implementation of message-driven architectures (MDA) within an internal network ("intra-organization communication"). Inter-organization messages and intra-organization messages serve different purposes and have different security requirements and design considerations. Nevertheless, similar design trade-offs apply to both, and the general principles of good message design outlined in TS-17 also apply to webhooks.

=== Client versus server

A note on the use of the terms "client" and "server" in the context of webhooks.

Webhooks _do not_ reverse the client-server relationship.

Consider a website that integrates with a payment service to handle payment card transactions. In this example, the website is the client and the payment gateway is the server. When a user makes a payment on the website, the website sends an HTTP request to the payment gateway to process the payment. When the payment is successfully processed, the payment gateway (the server) sends an HTTP request to the website (the client), via its webhook endpoint, to notify it of the successful payment.

Although it is the payment gateway that initiates the webhook request, the website is still the client and the payment gateway is still the server in terms of their conceptual relationship to each other.

Webhooks are an asynchronous communication pattern. In our example, the second request-response cycle – the webhook notification sent from the payment gateway back to the website – is actually a _delayed response_ to the first request initiated by the website (the client).

In terms of the semantics of HTTP, however, the client and server _are_ swapped around when the payment gateway sends the webhook notification to the website. The payment gateway is now the client, and the website is now the server. The normal semantics of HTTP response status codes apply.

For clarity, this technical standard uses the term "producer" to refer to a system that sends a webhook message, and "consumer" to refer to the system that receives it. This terminology avoids confusion around which is the client and which is the server.

=== Inbound versus outbound webhooks

A web service MAY implement either inbound or outbound webhooks, or both or neither.

* *Inbound webhooks*: These are _private_ endpoints that a service (the consumer) exposes to receive notifications from one or more third-party services (the producers).

* *Outbound webhooks*: These are messages sent out from a service (the producer) to the webhook endpoints of other services (the consumers).

Inbound webhooks are not part of an HTTP API's public interface. They are special-purpose private endpoints that exist only to facilitate integration with third-party systems on which the service depends. These endpoints are not used directly by the service's own users/customers, and are not included in any user-facing documentation.

Inbound webhooks may be exposed via different URLs schemas and HTTP methods than the service's main API endpoints, and things like payload schema and authentication mechanisms will be determined by the third-party services (the producers).

Outbound webhooks, on the other hand, are a form of event notification, and they are very much part of the application programming interface (API) of the service from which they are emitted. And yet they too sit apart from the main HTTP API endpoints of the service. Outbound webhooks may use different transport protocols, different file formats, different schemas, different methods of authentication, and they may even be versioned independently of the service's main API.

== Inbound webhooks

When implementing inbound webhooks as a consumer, the main design consideration is the URL scheme, which is normally the only thing that you have any control over. The upstream service that produces the events will dictate things like the payload schema and the authentication method that your webhook endpoints will be required to support.

=== URL schemes

The URL scheme for inbound webhooks MUST be distinct from the endpoints of the service's own HTTP API (if it has one). The aim is to avoid conflicts and allow the webhook endpoints to evolve independently of the main API endpoints.

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/_webhooks/{party}/{namespace}/v{version}/{event_type}/{...}
----

Where:

* `{party}` is the name of the third-party service (an event producer) that sends events to the endpoint. This is REQUIRED.

* `{namespace}` is an OPTIONAL path component used to scope a webhook to a particular service of the third-party event producer. This is required if a third-party offers multiple services, each of which emits events in different formats, and which therefore require differential handling by consumers.

* `{version}` is an OPTIONAL path component that identifies the version number of the event producer's webhook API or event schema that is supported by the endpoint. This can be omitted if the endpoint is designed to handle multiple versions of the producer's event schema in a backward-compatible way.

* `{event_type}` is an OPTIONAL path component that identifies a particular type of event that the endpoint is designed to receive. Normally, a single webhook endpoint is sufficient to handle all events from a particular producer. However, there may be cases where it is beneficial to have multiple webhook endpoints for the same producer, each tailored to specific event types or processing requirements. If this is not required, this path component MAY be omitted, or it MAY be the word "callback".

* `{...}` refers to any additional URL path components that are required by the event producer, for example for the purpose of passing resource identifiers.

The initial `/_webhooks/` path component is RECOMMENDED to clearly differentiate webhook endpoints from the main API endpoints of the service. The underscore prefix indicates that these endpoints are for internal use and are not part of the public HTTP API of the service. This path naming convention may also make it easier to differentiate cross-cutting concerns such as security policies, routing rules, monitoring, and logging configurations for webhook endpoints.

Consider the following examples of webhook URLs, which use the above scheme:

* `/_webhooks/authentiq/v3/callback`
* `/_webhooks/true-id/callback`
* `/_webhooks/transactify/v1/transaction-initiated`
* `/_webhooks/transactify/v1/transaction-complete`
* `/_webhooks/transactify/v2/transaction-initiated`
* `/_webhooks/transactify/v2/transaction-complete`

This fictional service exposes six webhook endpoints, which are used to receive notifications from three third-party event providers:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this producer. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* There's a similar webhook for a service called TrueID. This endpoint is not versioned, which means it could handle multiple versions of TrueID's webhook event schema if needed. We're pretending that this is an older identity verification service that is being phased out, to be replaced by AuthentiQ. In this transition phase, the system needs to support both producers – TrueID and AuthentiQ – in parallel. This demonstrates that this URL scheme supports zero-downtime transitions to alternative service providers.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

This webhook URL scheme supports multiple event producers. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. The URL scheme also makes it possible to incrementally transition from one service provider to another, eg. swapping the payment service gateway, without breaking your own service.

=== Versioning

The `{version}` component in the URL scheme is independent of the versioning scheme for the consumer's own HTTP API (if it has one). It may vary between webhook endpoints, too.

In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhook endpoints are different. These are scoped to the versions of the message schema that producers send to the webhook endpoints. Since it is the event producer that specifies the interface contract for its webhooks – the HTTP methods, payload structures, authentication mechanisms, and so on – then the `{version}` value is determined by them.

By including the message scheme version in their webhook URL schemes, consumers can incrementally transition to new breaking-change schemas without breaking their own services. During these transition periods, consumers might have duplicate webhook endpoints, like this:

* `/_webhooks/{party}/v3/receive-event`
* `/_webhooks/{party}/v4/receive-event`

[TIP]
======
If a producer does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the producer's own web service API. If this is not possible either, you can invent your own versioning system for the producer. This could be as simple as using the terms "latest" and "next" for the `{version}` path component.
======

=== Timeouts

Producers of webhook events MAY impose timeouts on how long they will wait for a response from the consumer's webhook endpoint. If the consumer does not respond within the timeout period, the producer MAY retry sending the event message, or it MAY discard it.

The timeout period is normally specified in the producer's documentation. This is usually quite short, typically 15 to 30 seconds. If the producer does not specify a timeout period, then it is RECOMMENDED to assume a timeout of 10 seconds.

Due to the potentially high latency of network communication, and the variable load on the consumer's servers, it is RECOMMENDED that webhook endpoints be designed to handle messages asynchronously. This means that the consumer should log messages on a queue, to be processed later, and return success status codes quickly, without waiting for the messages to be processes.

=== Status codes

When integrating with third-party services via inbound webhooks, those third-party services may require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the producer specifies the status codes that it expects in response, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular response codes from your consumer service.

But if a producer does not specify the status codes that it expects, then follow these best practices...

It is RECOMMENDED to return a `202 Accepted` for all success scenarios. This code indicates that the event has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook event receipts, as it allows the recipient to process the request asynchronously.

To indicate errors, if the producer does not specify what error codes it expects, then the following response codes are RECOMMENDED:

* `400 Bad Request` for client errors, which you should return when an event message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization checks (permissions, scopes).
* `404 Not Found` when the webhook endpoint does not exist, for example it has been deprecated or moved.
* `429 Too Many Requests` when rate limits have been exceeded.
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5xx` code, you are basically saying to the client "please retry this later".

== Outbound webhooks

For outbound webhook events, which your service produces and sends to the webhook endpoints of third-party consumers, it is RECOMMENDED to follow the https://www.standardwebhooks.com/[Standard Webhooks] specification.

Standard Webhooks is a community-driven initiative to standardize around industry best practices for webhook design. The specification is based on common patterns and prevailing conventions for event naming, payload structure, security and authentication, and delivery patterns.

The webhook ecosystem is highly fragmented, with each producer implementing webhooks differently. This makes it hard for producers and consumers to integrate with each other. Converging on a common standard for webhooks will make it easier for service providers to offer webhook notifications to their customers, and easier for their customers to integrate with them. It will also enable the development of shared tools and services that can be reused across multiple webhook implementations. The Standard Webhooks project already has a number of open source libraries, for multiple mainstream programming languages, to facilitate the implementation of webhooks in both producer and consumer systems.

Besides interoperability, the Standard Webhooks specification also promotes best security practices, offering solutions for attack vectors such as SSRF, spoofing, and replay attacks.

See the https://github.com/standard-webhooks/standard-webhooks[Standard Webhooks README] for more information about the project and specification, and links to open source libraries and reference implementations. The rest of this section specifies an extended subset of Standard Webhooks. These guidelines are fully compliant with Standard Webhooks, but they narrow some choices while extending guidance in other areas.

=== Secure protocol

All outbound webhook messages MUST be delivered over HTTPS.

Although digital signatures (see below) guarantee the authenticity and integrity of messages in transit, they do not provide confidentiality. Messages delivered over public networks using insecure transport protocols can be easily intercepted, risking leakage of sensitive data.

=== HTTP methods

All HTTP messages sent to consumer webhook endpoints MUST use the `POST` HTTP method.

=== HTTP headers

As per Standard Webhooks, the following three HTTP headers are REQUIRED to be sent with every webhook message:

* `Webhook-ID`: A unique identifier for each discrete webhook message. It is RECOMMENDED to be a UUID. It MUST remain the same for every delivery of the same message, eg. when a message is retried after a failed delivery. Consumers can use this an an idempotency key, so they process each message once only. The webhook ID also plays a role in the security scheme.

* `Webhook-Timestamp`: Unix timestamp of the time when the message was sent from the producer's servers. For compliance with Standard Webhooks, the value MUST be an integer representing the number of seconds since the Unix epoch; other date-time formats are not supported. If delivery is attempted multiple times, eg. due to an automated retry mechanism, the timestamp MUST be updated for each attempt.

* `Webhook-Signature`: A space-delimited list of HTTP message signatures, which can be used by consumers to verify the message's authenticity and integrity. The reason it is a list, and not just one signature, is to support zero-downtime secret rotation. See the section on security and authenticity for more details about how this works.

The values of all three headers – `Webhook-ID`, `Webhook-Timestamp`, and `Webhook-Signature` – MUST be generated by the producer and MUST NOT be configurable by the consumer. This constraint is necessary to achieve a full security profile.

[NOTE]
======
Standard Webhooks specifies the header field names using lowercase letters, eg. `webhook-id`. However, https://datatracker.ietf.org/doc/html/rfc7230#section-3.2[RFC 7230] specifies that HTTP header fields be processed in a case-insensitive manner by both clients and servers. This technical standard RECOMMENDS the more commonplace Pascal Case naming convention.

For compliance with Standard Webhooks, these non-standard headers MUST NOT be prefixed with `X-`. This breaks the convention recommended in *link:../016/README.adoc[TS-16: HTTP APIs]* for custom headers, but it is necessary for compliance with Standard Webhooks.
======

=== Payload schema

The payload schema defines the structure and format of the data that will be sent to the webhook endpoints of consumer systems. This is specified by producers. A well-defined payload schema is crucial for ensuring that webhook consumers can correctly interpret and process the events they receive.

The payload MUST be encoded in the body of HTTP messages. HTTP headers MUST NOT be used to transmit any part of the payload – these are reserved for metadata about the message instance only.

The payload SHOULD be in the JSON format, with a `Content-Type` header of `application/json`. In rare cases, other formats such as XML or form-encoded data MAY be used if there is a specific requirement for it. But JSON is by far the most widely used format for webhooks and it offers the best interoperability.

The payload structure is an object with the following top-level properties:

* `type`: Identifies the event type.
* `timestamp`: The date and time when the event occurred, in ISO 8601 format.
* `data`: Data specific to the event type.
* `metadata`: Optional metadata about the event.
* `links`: A list of related web resources and HTTP API operations.

The `type`, `timestamp` and `data` properties are REQUIRED for compliance with Standard Webhooks. The `metadata` and `links` properties are suggested by this technical standard as OPTIONAL extensions to the Standard Webhooks payload schema. Producers MAY further extend this schema with additional properties specific to their use cases.

Example:

[source,json]
----
{
  "type": "user.created",
  "timestamp": "2014-01-13T08:01:35Z",
  "data": {
    "id": "123",
    "name": "John Doe",
    "email": "john.doe@example.com"
  },
  "metadata": {
    "created_at": "2022-11-01T09:15:00Z",
    "updated_at": "2023-03-15T12:34:56Z"
  },
  "links": [
    {
      "rel": "self",
      "href": "https://api.example.com/users/123"
    }
  ]
}
----

==== Event type

The value of the `type` field identifies the type of event being sent.

It is RECOMMENDED that event types be organized into a hierarchy using a dot-notation, eg. `"user.created"`, `"user.updated"`, `"user.deleted"`, `"invoice.created"`, `"invoice.paid"`, etc. The components of the event type identifiers SHOULD be restricted to a small set of ASCII characters – Standard Webhooks recommends `[a-zA-Z0-9_]`.

The schema of the `data` object MAY differ between event types. The only requirement is that each discrete event type has a single consistent `data` schema for every message of that type.

==== Timestamp

The value of the `timestamp` property is not actually a timestamp but an ISO 8601-formatted date-time string, as specified by Standard Webhooks. The format differs from the `Webhook-Timestamp` field, which is an actual timestamp. This inconsistency is unfortunate, but it is REQUIRED to maintain compliance with Standard Webhooks.

The value represents the time when the event occurred. This is not necessarily the same time when the event message was sent – it is expected to be a bit earlier.

The `timestamp` value of an event MUST NOT change, even if the message is resent to consumers. By contrast, the value of the `Webhook-Timestamp` header field MUST change every time the same message is retried or replayed. Semantically, the two date-time values refer to different events (event creation versus message delivery) and they serve different purposes.

.Replay attacks
****
Replay attacks occur when an attacker intercepts a valid message and resends it later, perhaps with a modified payload. This can lead to unintended side effects, such as duplicate transactions or unauthorized actions.

Including timestamp information in messages is a common technique to protect consumers from replay attacks. This value MUST be signed by message producers, so consumers can verify the integrity of the message's timestamp (not only the payload).

With the authenticity of the message and its timestamp verified, consumers then have the option to reject messages older than a certain threshold. The appropriate threshold will vary by message type, and to accommodate different latency and clock-drift between different systems.
****

==== Data

The value of the `data` property MUST be an object with at least one property (ie. it MUST NOT be an empty object).

The `data` object is the actual event data that is communicated with the consumer.

Each event type MUST have a well-defined schema for its associated data object. This is the main design consideration when implementing outbound webhooks. Standard Webhooks specifies everything else about the HTTP messages used to package webhook events. All that producers have left to decide is what information they want to send to their consumers.

In designing your event data schema, err on the side of "thin" objects that communicate just the minimal data that a consumer may need to sync its state. Example:

[source,json]
----
{
  "type": "contact.updated",
  "timestamp": "2023-03-15T12:34:56Z",
  "data": {
    "id": "d9e18267-b078-49a5-a8b5-88571c88251c",
    "first_name": "Jane",
    "last_name": "Doe",
    "email": "jane.doe@example.com"
  }
}
----

An extreme implementation of thin data schema would see no state being communicated via webhook events at all. The webhook payloads would thus be very "thin". In the following example, the event informs us that a contact resource has been updated, but that's all. We're given only just enough information to be able to retrieve the updated state, if we want it, via a follow-up request to the service's regular HTTP API endpoints.

[source,json]
----
{
  "type": "contact.updated",
  "timestamp": "2023-03-15T12:34:56Z",
  "data": {
    "id": "d9e18267-b078-49a5-a8b5-88571c88251c"
  }
}
----

By comparison, a "full" data object would include _all_ the fields associated with the resource identified by the event type. It may even include information about related entities. This is a *stateful* design, in which the consumer is given all the information it needs to update its own state without having to make any further API calls to the producer service. Example:

[source,json]
----
{
  "type": "contact.updated",
  "timestamp": "2023-03-15T12:34:56Z",
  "data": {
    "id": "abc123",
    "first_name": "Jane",
    "last_name": "Doe",
    "email": "jane.doe@example.com",
    "phone": "+44-7911-123456",
    "address": {
      "street": "123 High Street",
      "city": "London",
      "postal_code": "NW3 5LP",
      "country": "United Kingdom"
    },
    "tags": ["newsletter", "vip", "event-attendee"],
    "status": "active",
    "custom_fields": {
      "preferred_language": "English",
      "referral_source": "LinkedIn",
      "birthday": "1990-07-22"
    }
  }
}
----

There are pros and cons to both approaches. The main advantage of full data objects is that consumers will immediately have all the information they need to update their state, and load will be reduced on the producer due to fewer API calls being required from webhook consumers. On the other hand, thin payloads may offer better performance (due to smaller message sizes, faster database queries, and less server-side processing overall) and better future proofing (you can make a thin object full, but not the other way around, without breaking backwards compatibility).

The main advantage of very thin payloads is that the HTTP API is preserved as the source of truth for the application's state. There is less likelihood of clients ending up in invalid state, due to event messages being received and processed out-of-order, for example. Data access audit trails are simpler to maintain, too, since all data is accessed through the HTTP API. Thin messages also have a better security profile, as there are inherently fewer risks with things like replay attacks and PII leakage.

Thin and full data objects are not a binary decision. Often, the optimum design will be somewhere in the middle.

This technical standard does not impose a technical limit on the size of webhook messages, and therefore the size of data objects is uncapped. However, it is RECOMMENDED to keep overall payloads smaller than 20kb. Larger payloads may impose burdensome load on webhook consumers. If you need to transfer large amount of data, such as images or other media files, then consider making those available via `GET` endpoints in a regular HTTP API or other web location, and use webhook messages to communicate the links from which consumers can fetch those resources.

Payloads MAY be minimized. This is more beneficial for large payloads than small ones. Minimization, if done, SHOULD be applied across all messages sent from the producer service, to ensure consistent processing on the consumer side.

==== Metadata

The `metadata` property is OPTIONAL. It is not part of the Standard Webhooks specification, so there is extra cost to consumers to process this. For this reason, event metadata SHOULD NOT include any data that is essential for consumers to process the events.

Metadata is data that is not part of the resources represented in the `data` object, but which provides additional information about those resources. A good use case for the `metadata` object is to communicate machine-generated data, which can be read but not written by clients, such as `created_at` and `updated_at` fields. Other use cases include communicating things like event IDs and source information (the name of the service from where the event originated), and other information that would be useful to log to support debugging.

The `metadata` object MUST be used only to communicate metadata about _resources_ represented in the `data` object. It MUST NOT be used to communicate metadata about the webhook event – that's the role of the message's HTTP headers.

==== Links

The `links` property is OPTIONAL. If included, its value MUST be an array with one or more objects that conform to the following schema:

[source,json]
----
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "rel": {
      "type": "string"
    },
    "method": {
      "type": "string"
    },
    "href": {
      "type": "string"
    }
  },
  "additionalProperties": false
}
----

Example:

[source,json]
----
{
  "links": [
    {
      "rel": "self",
      "method": "GET",
      "href": "https://api.example.com/v1/{namespace}/{resource}/{uuid}"
    },
    {
      "rel": "delete",
      "method": "DELETE",
      "href": "https://api.example.com/v1/{namespace}/{resource}/{uuid}"
    }
  ]
}
----

The objects encode information about how consumers can fetch related data, and perform related operations, via the producer's regular HTTP API endpoints. See *link:../016/README.adoc[TS-16: HTTP APIs]* for more information.

The `links` object is another extension to Standard Webhooks, RECOMMENDED by this technical standard. The purpose of this object is to provide in-band API documentation – information that SHOULD be readily available to developers of consumers systems via other channels.

=== Security and authenticity

Webhook messages are just regular HTTP messages that could originate from any source. While TLS provides a high degree of confidentiality during transit, it does not guarantee the authenticity or integrity of messages. TLS cannot guarantee end-to-end message integrity when intermediaries (eg. proxies, load balancers) terminate and re-establish the connection.

Therefore, before processing webhook messages, consumers MUST verify the authenticity and integrity of the messages – that they come from the expected producer (authenticity), and that they have not been tampered with by a malicious third-party during transit (integrity).

==== Authentication mechanisms for webhooks

The following table summarizes authentication mechanisms that can be used in webhook implementations.

Auth systems trade simplicity for security. In the table, from top to bottom the mechanisms are ordered from the easiest to implement to the hardest, from the least secure to the most. But this is a generalization. The security profile is determined by the overall webhook system design, including the types of data being transmitted, retry mechanisms and replay policies, the level of configurability offered to consumers, the security of the underlying infrastructure, the operational practices of both producer and consumer systems, and so on. For example, messages with thin payloads – those that do not contain any resource state, just identifiers – are inherently more secure than fat payloads, and therefore there are fewer risks associated with exploits like replay attacks. Weaker security mechanisms may be acceptable in such cases.

Authentication mechanisms are not mutually exclusive either. They can be combined to provide layered security. For example, IP allow-listing is a good thing to offer consumers as an optional layer of protection over message signatures. Even tokens can be combined with signatures, to give consumers the freedom to apply scopes (permissions) to a producer's messages.

[valign="top"]
|===
|Mechanism |Description |Pros |Cons |Comments

|*IP allow-listing*
|Requires the producer service to be run on infrastructure with static IP addresses, giving consumers the option of allowing those IPs through their firewall.
|✅Simple to implement +
 ✅Infrastructure configuration only (no application code changes)
|❌Not secure (IP addresses can change and be spoofed) +
 ❌Depends on static IPs on producer side
|IP allow-listing is not sufficient on its own as an _authentication_ mechanism. It's only a traffic _filtering_ system that provides a little extra security on top of the primary authentication system.

|*HTTP basic auth*
|The consumer supplies a username and password to the producer. The producer returns these credentials via the `Authorization` header of its webhook messages to the consumer.
|✅Simple to implement +
 ✅Widely supported +
 ✅HTTP standard +
 ✅Passwords are easy to change
|❌Raw credentials transmitted +
 ❌Depends on end-to-end HTTPS encryption +
 ❌Message integrity remains unverified +
 ❌Zero-downtime secret rotation not possible (requires client-server coordination)
|Very easy to implement but not recommended for high-security applications. A good choice where there is only a single consumer, or where the consumers are all in the same organization as the producer and credentials are centrally managed.

|*Bearer token or API key*
|The consumer generates a token that is shared with the producer. The producer returns the token in webhook messages to the consumer via the HTTP `Authorization` header. A token may be any arbitrary string (like a regular password), but standards such as JWT can be used to increase the security profile by encoding claims (permissions), expiration times, and revocation metadata into tokens.
|✅Simple to implement +
 ✅Common pattern +
 ✅Raw credentials (username + password) not transmitted +
 ✅Tokens can be rotated separately to user passwords +
 ✅Zero-downtime token rotation is possible in certain implementations +
 ✅Lots of flexibility in token design +
 ✅JWTs can be securely signed to guarantee their authenticity and integrity +
 ✅JWS (JSON Web Signature) can be used to sign the entire message payload +
 ✅JWTs can have built-in expiration dates +
 ✅JWTs can be scoped (permissions) +
 ✅JWTs can include other arbitrary metadata/claims
|❌Need to duplicate message content in signature data +
 ❌Can't revoke tokens after sending +
 ❌More responsibility is placed on the consumer to generate secure tokens, and to manage the lifecycle of tokens
|More secure than basic auth. Message integrity is guaranteed, and replay attacks and other vulnerabilities lessened, by using JWS (JSON Web Signature) to sign the whole message (headers + payload), the trade-off being is that the message content is effectively duplicated in the signature. Security can be tightened further by using multiple tokens, each dynamically-generated and scoped to a particular resource, transaction, or user journey, so reducing the blast radius if a token is compromised. But the main advantage of JWTs over message signatures is that consumers can encoded appropriate claims in their tokens, such as scopes (permissions) and expiration times, which gives them more control over access to their webhook endpoints.

|*HMAC signatures (symmetric) with SHA-256 hashing*
|A secret is generated by the message producer and shared with the message consumer. Using the shared secret, the producer creates a HMAC hash of the message payload. The hash serves as a signature and is sent with the message as a header (the signature may be base64-encoded for compactness). To verify authenticity, the consumer recreates the hash and compares it to the received hash.
|✅Strong authenticity guarantees (no secrets transmitted in webhook messages) +
 ✅Verifies message integrity (ie. protects against tampering) +
 ✅Timestamp verification protects against replay attacks +
 ✅Industry standard; good library support +
 ✅Producer is responsible for key generation and management +
 ✅Easy to implement on consumer side +
 ✅Zero-downtime secret rotation is possible +
 ✅Not dependent on end-to-end HTTPS encryption (though still recommended)
|❌Depends on single secret key shared between producer and consumer +
 ❌New complexity of securely distributing secrets +
 ❌Insider threat (both parties know the secret) +
 ❌Timestamp verification depends on clock synchronization
|Industry standard, widely used by major services like GitHub, Stripe, Spotify, etc. Very secure. Does not depend on end-to-end HTTPS encryption, as message integrity can be verified without this. However, depends on a single secret shared between both producer and consumer – therefore a producer can't genuinely _guarantee_ the authenticity and integrity of their messages if they do not fully control the key distribution.

|*Public key signatures (asymmetric)*
|A digital signature is generated by the producer using a private key, and verified by the consumer using a public key.
|✅Provides very strong authenticity guarantees (no secrets are shared) +
 ✅Private key is more secure as held by only one party (the producer) +
 ✅Public key can be freely distributed (no need to keep it secret) +
 ✅Producer is responsible for key generation and management +
 ✅Verifies message integrity (ie. protects against tampering) +
 ✅Timestamp verification protects against replay attacks +
 ✅Zero-downtime secret rotation is easy +
 ✅Most secure cryptographically +
 ✅Not dependent on end-to-end HTTPS encryption (though still recommended)
|❌More complex to implement on both producer and consumer sides +
 ❌Requires deeper technical knowledge (Public Key Infrastructure, PKI) +
 ❌Slightly higher computational overhead +
 ❌Less widely used; less library support
|Improves on the security of symmetric keys by keeping the private signing key under the control of the producer. The corresponding public key can be assumed to be public (shared widely). Recommended for high-security applications. Very easy key rotation.

|*OAuth 2.0*
|An extension of bearer token authentication, in which a producer authenticates with an auth server to obtain a short-lived access token, which it then uses to authenticate with the consumer's webhook endpoint for delivery of a single message.
|✅Industry standard +
 ✅Short-lived tokens reduce risks if intercepted +
 ✅Centralized token management (on the consumer side) +
 ✅Tokens can be revoked +
 ✅Provides fine-grained access control (scopes/permissions)
|❌More complex to implement and manage +
 ❌Higher integration and maintenance costs for webhook consumers +
 ❌Additional latency (token fetch)
|Rarely used in webhook implementations because it depends on the consumer providing an OAuth service. May be appropriate for some use cases where delegated access is a requirement to access a consumer's systems (ie. where all operations on the consumer system are performed on behalf of an authorized user). This design may be appropriate where webhook messages initiate destructive actions that require elevated privileges, but such a requirement tends to be outside of the scope of webhooks, which are merely event notifications.

|*Mutual TLS (mTLS)*
|Both client and server authenticate with certificates. The producer has a client certificate + private key. The consumer has a server certificate + private key. Each side has the others Certificate Authority (CA) certificate to validate against. At the TLS layer, the producer presents its client certificate and the consumer presents its server certificate, and each side verifies the other against trusted CAs. The handshake concludes and the connection proceeds only if both certificates are valid.
|✅Very strong authentication +
 ✅Guarantees authenticity of both parties – the producer and the consumer +
 ✅Encrypts and authenticates at the transport layer +
 ✅Minimal application-level code needed
|❌Much more complex to set up +
 ❌Complex certificate generation and distribution +
 ❌Hard to rotate certs +
 ❌Hard to debug; TLS errors can be quite cryptic +
 ❌Requires both sides to have control over their infrastructure
|This mechanism offers the strongest security guarantees, as it gives cryptographic proof of identity on _both_ sides. End-to-end encryption with verified identifies protects against MITM attacks. This will be appropriate in the highest-security environments such as financial trading, and it is sometimes used in intra-organization multi-cloud enterprise integrations.
|===

According to Standard Webhooks, over 65% of webhook implementations use signatures for authentication and verification of webhook message integrity. Signatures are a really good fit for message-driven communication patterns – this is their main use case.

In the wild, symmetric HMAC signatures are the most popular. HMAC-SHA256 is fast (and often hardware accelerated) and ubiquitous (it is natively supported by most mainstream programming languages). This authentication scheme offers a good balance between security and usability. It is easy to implement and, if done well, has excellent security. Critically, responsibility for secret generation and key lifecycle management is with the producer, whereas token auth shifts this responsibility onto consumers.

Asymmetric signatures are securer still. They improve on the security of symmetric signatures by eliminating the need to share _any_ secrets between the producer and consumer systems. This is a significant advantage. Producers are responsible for generating public-private key pairs and for managing the lifecycle of their private keys. Consumers are given the corresponding public keys, which they use to verify the signatures on incoming messages. Public keys do not need to be kept secret, so there is no risk of them being leaked or intercepted. Therefore producers can _guarantee_ the authenticity and integrity of their messages, because only they know the signing secret – they own the trust. With symmetric signatures, producers cannot make this guarantee because they have no control over how their consumers store and process the shared signing key.

In addition, Ed25519 (an asymmetric signature algorithm) is also specifically designed to avoid patterns in memory access that could be exploited via side-channel attacks – a significant advantage over some older algorithms like RSA. This makes Ed25519 a good choice for modern cryptographic applications, like SSH and API authentication, and also for webhook authentication.

Asymmetric signatures are a little more complex to implement, and there are fewer libraries and reference implementations to help. Asymmetric signatures can also be more CPU-intensive to produce, although modern cryptography algorithms such as Ed25519 are still very fast, certainly enough to be usable in high-throughput systems.

For most use cases, the increased costs of implementing asymmetric signatures will be outweighed by the reduced risks, compared to symmetric signatures. Asymmetric signatures are RECOMMENDED in scenarios where you do not control the security of both the client and server systems – which is the case for webhooks (the consumers of events are systems owned and operated by third-parties).

Other mechanisms to verify the authenticity of webhook messages include HTTP basic auth (username + password) and bearer auth (tokens). Basic auth has significant security weaknesses, as it involves transmitting raw credentials in every message. Bearer tokens are much better, and when implemented using JWTs (JSON Web Tokens) that are cryptographically signed, the security profile is equivalent to message signatures. Bearer tokens have one main advantage over message signatures: they can include additional metadata (such as user roles or permissions) in the token payload. The trade-off is that responsibility for token generation and validation is shifted from the producer to the consumer.

OAuth, mutual TLS, and other options solve problems in niche use cases. These authentication mechanisms are not appropriate for most general-purpose webhook implementations.

Therefore, this technical standard says that HTTP message signatures SHOULD be used in webhook implementations, and asymmetric signatures are RECOMMENDED over symmetric ones. Signed bearer tokens, implemented as JWTs, MAY be used as an alternative to message signatures, in use cases where there are good reasons to give consumers more control over access to their webhook endpoints (via scopes/permissions encoded in the tokens).

==== Webhook metadata

It is not enough to use strong cryptographic primitives for the signature. HTTP signatures MUST be implemented in a particular way for the messages to be fully secure from all possible attack vectors. This section describes a security scheme, based on Standard Webhooks, to achieve that.

A secure signature scheme requires that not only the authenticity of the message payload be verifiable, but also the message's metadata – its unique identifier, and its timestamp (representing the time of the delivery attempt).

Thus, the following HTTP headers (described above) are all part of the security scheme:

* `Webhook-ID`: A unique identifier for the webhook message.
* `Webhook-Timestamp`: Unix timestamp when the message was sent.
* `Webhook-Signature`: The webhook message's signature, used by consumers to verify the message's authenticity and integrity.

Example:

[source,http]
----
POST /_webhooks/rolodex/v1/callback HTTP/1.1
Host: api.example.com
Webhook-ID: 2eb7c6b3-912e-4336-a2a7-7fbb6be1f098
Webhook-Timestamp: 1742001300
Webhook-Signature: v1,K5oZfzN95Z9UVu1EsfQmfVNQhnkZ2pj9o9NDN/H/pI4= v1a,hnO3f9T8Ytu9HwrXslvumlUpqtNVqkhqw/enGzPCXe5BdqzCInXqYXFymVJaA7AZdpXwVLPo3mNl8EM+m7TBAg==
Content-Type: application/json

{
  "type": "contact.updated",
  "timestamp": "2025-03-15T12:34:56Z",
  "data": {
    "id": "d9e18267-b078-49a5-a8b5-88571c88251c",
    "first_name": "Jane",
    "last_name": "Doe",
    "email": "jane.doe@example.com"
  }
}
----

The value of the `Webhook-Timestamp` header field is the timestamp when the message was sent by the producer. This will differ to the timestamp of the event itself, which is captured in the payload via the `timestamp` property (see above). The `Webhook-Timestamp` value MUST be updated for every message retry, but the `timestamp` MUST NOT be. This is an important security measure that will prevent replay attacks – see the *Signature scheme* section below for how this works.

The `Webhook-ID` is a unique identifier associated with a specific logged event. It MUST NOT change between retries of the same webhook message. Consumers are RECOMMENDED to use this as an idempotency key, which will help protect them against replay attacks.

==== Signature scheme

For full security, the signature MUST sign all of:

* The message identifier (from the `Webhook-ID` header)
* The message timestamp (from the `Webhook-Timestamp` header)
* The message payload (the HTTP message body)

Each part is concatenated using dot notation:

.Message signature scheme
----
{id}.{timestamp}.{payload}
----

Example:

----
2eb7c6b3-912e-4336-a2a7-7fbb6be1f098.1742001300.{
  "type": "contact.updated",
  "timestamp": "2025-03-15T12:34:56Z",
  "data": {
    "id": "d9e18267-b078-49a5-a8b5-88571c88251c",
    "first_name": "Jane",
    "last_name": "Doe",
    "email": "jane.doe@example.com"
  }
}
----

If the JSON payload is minified for transit, then it is the minified version that MUST be used to generate the message signature (thus there will be no line breaks in the signed content). The payload that is sent MUST match exactly the payload that is signed, else verification will fail on the consumer side.

[NOTE]
======
Even a stray space in the HTTP message body will be enough to make the signature invalid. This sort of thing is a common failure mode in webhook implementations. A common issue on the consumer side is when HTTP abstractions automatically parse JSON content into objects, and then serialize them again when the application retrieves the original body string. Differential serialization between the producer and the consumer leads to signature verification failures. To avoid this, it is RECOMMENDED that consumers access the raw HTTP body as a byte stream or string, without any parsing or serialization, when verifying signatures.
======

Signing all three parts – not only the message payload, but also its identifier and timestamp – is REQUIRED to protect consumers against the full range of possible attack vectors. Signing the timestamp means consumers can verify the integrity of the timestamp, and in turn protect themselves against replay attacks (by rejecting messages older than a configured threshold). Verification of the message ID helps protect against spoofing, and further protects against replay attacks (because the webhook ID can be trusted as a valid idempotency key). Verification of the payload guarantees that the content hasn't been tampered with in transit, protecting against man-in-the-middle or injection attacks.

The `Webhook-ID` and `Webhook-Timestamp` MUST be generated by the producer and MUST NOT be controllable in any way by the consumer. In addition, these values MUST NOT contain any periods (full-stops), so as not to create any parsing problems on the consumer side.

==== Signature systems

Standard Webhooks specifies two HTTP signature systems:

* Symmetric keys: HMAC-SHA256 signatures using a shared secret key.
* Asymmetric keys: Ed25519 signatures using a public/private key pair.

Producers MAY choose either one of these signature systems. Alternatively, producers MAY implement both systems in parallel, allowing consumers to choose which one they will use, and thereby opting in to a security profile that best fits their risk tolerance.

.Standard Webhooks implementations
|===
| |Symmetric |Asymmetric

|Signature scheme
|`HMAC-SHA256`
|`ed25519`

|Signing secret
|Random. Between 24 bytes (192 bits) and 64 bytes (512 bits)
|Standard ed25519 key pair

|Secret serialization
|Base64-encoded, prefixed with `whsec_`
|Base64-encoded, prefixed with `whsk_` for the secret key and `whpk_` for the public key

|Signature version identifier
|`v1`
|`v1a`
|===

Signatures are base64-encoded for compactness in transit. The strings `whsec_`, `whsk_` and `whpk_` are prefixed to the signatures prior to base64-encoding. These prefixes are REQUIRED by consumers to identify the type of key being used to create the signature. (The prefixes are not part of the signatures themselves, so consumers MUST remove them before verifying the signature.)

In addition, the base64-encoded signatures are further prefixed with `v1` or `v1a`, followed by a comma, in the `Webhook-Signature` header. Because producers MAY send multiple space-delimited signatures via the `Webhook-Signature` header, consumers MUST use this prefix to identify the particular signatures they are capable of verifying. "v1" indicates a symmetric HMAC-SHA256 signature, and "v1a" indicates an asymmetric Ed25519 signature. Alternative signature schemes supported by Standard Webhooks in the future will presumably be "v2", "v3", etc.

Example:

----
Webhook-ID: msg_2KWPBgLlAfxdpx2AI54pPJ85f4W
Webhook-Timestamp: 1674087231
Webhook-Signature: v1,K5oZfzN95Z9UVu1EsfQmfVNQhnkZ2pj9o9NDN/H/pI4= v1a,hnO3f9T8Ytu9HwrXslvumlUpqtNVqkhqw/enGzPCXe5BdqzCInXqYXFymVJaA7AZdpXwVLPo3mNl8EM+m7TBAg==
----

.HTTP Message Signatures
****
It is worth mentioning https://datatracker.ietf.org/doc/html/rfc9421[RFC 9421: HTTP Message Signatures], which defines an alternative method for creating, encoding, and verifying digital signatures in HTTP messages.

Cleverly, this specification allows producers to declare in the message which parts of the message have been signed. Messages include a `Signature-Input` header that specifies which components were signed, while the `Signature` header carries the cryptographic signature itself. Verifiers can then check that those specific components haven't been tampered with.

HTTP Message Signatures can be a better option where you require greater flexibility in what gets signed, or if you prefer a more standardized solution. The trade-off is the HTTP Message Signatures are more complex, and the standard does not cover other aspects of webhook security as Standard Webhooks does.

[source,http]
----
POST /foo?param=value&pet=dog HTTP/1.1
Host: example.com
Date: Tue, 20 Apr 2021 02:07:55 GMT
Content-Type: application/json
Content-Digest: sha-512=:WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+T\
  aPm+AbwAgBWnrIiYllu7BNNyealdVLvRwEmTHWXvJwew==:
Content-Length: 18
Signature-Input: sig=("@method" "@authority" "@path" "@query" \
  "content-digest" "content-length" "content-type")\
  ;alg="rsa-pss-sha512";created=1618884473\
  ;keyid="RSA (X.509 preloaded)"
Signature: sig=:k2kD1VAw9TOA72zoDzt3ZAOdjhOg9edgBYqsvyQb5mBnwzY/fKz\
  5W30tZud9YA4o8NfCYh8VnW5m4fxFsWCTOOQbrsWXmmGSKtblfi3o5DxlHJcUkrAH\
  /d13tmy7r2Jtipjrhv6Ca67VU9z1Q2S8Zd87sNxFnyhIxX+CiKJ+i+P6XfJfeTbCV\
  UIo8cTTqLD9go9xdZ8sSUkU9kDy5WxghbbPV/y9rmmigO0y3qxI8/UGZ/OWhsN13O\
  zvE0SBj8tCYQ8qlh20zjNmJm0GN62RJXK0dX1h83Gh0IIXGPPmWQNCavO4hAbY3eW\
  7nhGdEjlh364x8dd323UKuMfuwqYEyg==:

{"hello": "world"}
----
****

==== Key rotation

The `Webhook-Signature` header MAY contain multiple signatures, space-delimited, for the same message. This design supports zero-downtime secret rotation.

For example, if a consumer requests secret rotation, their messages can be signed with both the old and the new keys, and both signatures sent in the `Webhook-Signature` header, for a short period of time. Consumers can try to verify each signature until one matches. This means there is "no downtime" because old messages, signed with the old key, can still be processed. (This system also supports producers and consumers upgrading from symmetric to asymmetric keys.)

However, in the event that a private key (for asymmetric signatures) or shared secret key (for symmetric) is compromised, producers MUST immediately rotate the compromised key and stop signing new and retried messages with it. This is important to limit the attack vectors that become possible when a signing key is compromised. Consumers will still be able to verify and process delayed messages signed with the old compromised key. They may not be able to process new messages signed with the new secure key, but at least these failed messages can be retried later, after the consumer has installed the new verification key.

==== IP allow-listing

Some webhook consumers have firewalls in front of their webhook endpoints, which require messages to be sent from a predefined list of IP addresses (aka. IP allow-listing). It is RECOMMENDED that producers support this use case, which requires static IP addresses to be associated with the servers that send webhook messages.

IP allow-listing adds an extra layer of security, but it is only a traffic _filtering_ mechanism and not a proper _authentication_ mechanism. Since IPs can change and are easily spoofed, IP allow-listing MUST NOT be the sole authentication mechanism.

==== Other security requirements

Achieving good security in webhook implementations requires a multi-layered approach. The right mix will depend on the threat model and the sensitivity of the data, but as a starting point the following combination is a RECOMMENDED baseline:

* Secure message transport over TLS/HTTPS.
* HMAC or (better still) asymmetric signatures for primary authentication and to validate message integrity.
* Timestamp validation on the consumer side to protect against replay attacks.
* Unique message IDs to support idempotency and to further protect against replay attacks.
* Highly-automated key revocation and rotation mechanisms on the producer side to limit the blast radius if a key is compromised.
* Rate limiting on the consumer side to protect against denial-of-service attacks.
* Logging of failed signature verification attempts on the consumer side, to detect potential security incidents.
* Static IP addresses on the producer side, giving consumers the option of implementing IP allow-listing.

Signing keys MUST be unique _per endpoint_ for symmetric signatures, and they MUST be unique _per customer_ for asymmetric signatures (but MAY be unique _per endpoint_ too). Limiting the scope of signing keys reduces the blast radius if a key is compromised. If a signing key is leaked, for example by being committed to a public Git repository, then only the messages sent to that particular endpoint (for symmetric signatures) or to that particular customer (for asymmetric signatures) are at risk. Other endpoints and customers remain secure.

Producers MUST NOT reuse signing keys for multiple customers.

Producers MUST use a secure random number generator to create signing keys. For symmetric keys, the key length MUST be between 24 bytes (192 bits) and 64 bytes (512 bits). For asymmetric keys, the standard ed25519 key pair MUST be used.

Producers MUST implement key invalidation and rotation mechanisms. This MUST be highly automated.

Signatures are trusted as much as the keys used to sign them. Therefore, particular care needs to be taken to keep signing keys secure. For symmetric keys, producers MUST provide a secure mechanism for consumers to retrieve the shared secret key, and to request key rotation. Typically, this would be an authenticated endpoint in the producer's regular HTTP API. The shared secret MUST be transmitted securely, eg. over HTTPS, and MUST NOT be exposed in logs or error messages. Similar mechanisms SHOULD be used for asymmetric keys, though of course there a fewer risks associated with public keys.

Consumers MUST verify the signature of every webhook message before processing it. If the signature verification fails, the message MUST be logged as a potential security incident. It is RECOMMENDED that producers provide a mechanism by which such incidents can be reported back to them, too.

Consumers SHOULD configure a reasonable tolerance window for the `Webhook-Timestamp` value, to protect against replay attacks. A typical tolerance window is 5 minutes (300 seconds). If the timestamp is outside of this window, the message MUST be rejected and SHOULD be logged as a potential security incident.

Producers are REQUIRED to have accurate clocks, synchronized to a reliable time source (eg. via NTP). Consumers are also RECOMMENDED to have clock synchronization, but this is less essential if they configure a sufficiently large tolerance window for the `Webhook-Timestamp` value.

Consumers SHOULD store the `Webhook-ID` values of recently processed messages. The retention period for webhook ID logs MUST be longer than the tolerance window for the `Webhook-Timestamp` value. The `Webhook-ID` serves as an idempotency key. It allows consumers to detect and reject duplicate messages (eg. replayed ones that succeeded the first time). It also gives extra protection against replay attacks. If a message is received with a `Webhook-ID` that has already been processed, and within the timestamp tolerance, the message MUST be rejected. However, it does not need to be logged as a potential security threat – more likely, it's just a duplicate message.

When verifying asymmetric signatures, consumers SHOULD be encouraged to use battle-tested cryptographic libraries, and to keep this dependency up-to-date. Producers SHOULD recommend a list of suitable libraries for consumers to use.

When verifying symmetric signatures, consumers are RECOMMENDED to use a constant time comparison function, rather than just a regular string comparison, when verifying the actual signature against the expected signature. Consider the following code:

[source,python]
----
if actual_signature == expected_signature:
    grant_access()
----

This looks harmless, but it exposes consumers to timing attacks. This is because the time taken to compare the two strings will vary depending on how many characters match at the start of the strings. Consider the following values:

|===
|actual_signature |expected_signature |Comment

|"ooooo" |"xoooo" |fails fast, because the first character is different
|"ooooo" |"oxooo" |fails slightly slower, because the second character is different
|"ooooo" |"oooox" |fails slower still
|===

By measuring tiny differences in the time it takes a consumer to respond to a webhook message, an attacker can deduce the expected signature one character at a time. A constant-time comparison function always takes the same amount of time to compare two strings, regardless of how many characters match or not, so closing off this potential exploit.

[source,python]
----
import hmac
if hmac.compare_digest(actual_signature, expected_signature):
    grant_access()
----

=== Status codes

Producers of webhook messages will need to consider the status codes that they will require consumer services to return in response to their webhook messages.

The following policy is RECOMMENDED:

* To accept any `2xx` status code to indicate successful processing of a webhook message, ie. any `2xx` code will be treated by you as `202 Accepted`.

* To treat `5xx` status codes as errors in the consumer service, which will trigger retry and dead-letter queue mechanisms on the producer side. In addition, `502 Bad Gateway` and `504 Gateway Timeout` usually indicate that the server is under load, so the producer SHOULD throttle subsequent requests.

* To treat recurring `410 Gone` responses as an indication that the consumer no longer wishes to receive webhook messages. The producer SHOULD automatically disable the consumer's webhook configuration, and stop sending messages to their webhook endpoints, if this status code persists for more than 1 day.

* To treat `404 Not Found` responses as an indication that the consumer's webhook endpoint is misconfigured, or that it has been moved or deleted. The producer SHOULD handle this in the same way as a `410 Gone`, but in addition the producer SHOULD notify the consumer of the issue.

* To treat `429 Too Many Requests` as a rate limit scenario. The producer SHOULD pause sending further messages to the consumer's webhook endpoint for a period of time, before resuming through the normal retry mechanism. In other words, the normal retry schedule is delayed a little, giving more time for the hit count to be reset on the consumer side. It is OPTIONAL that producers automatically adjust their retry interval based on `Retry-After` headers returned by consumers.

* To treat any other `4xx` client errors in the same way as `5xx` server errors, but in addition log them for further investigation – because the producer's webhook implementation may be at fault.

* To treat `1xx`, `3xx`, and all other status codes as generic `500` server errors. Producers MUST NOT follow redirects, as this is a potential security risk and puts unnecessary load on the producer system. If consumers move their webhook endpoints, they are REQUIRED to update their configuration in the producer system.

=== Delivery and reliability

==== Timeouts

Connection timeouts – in which a webhook message is sent to a consumer but the connection is closed before a response message is returned – are a common failure mode in webhook implementations Producers SHOULD set a reasonable timeout value for webhook requests – somewhere between 15 and 30 seconds would be reasonable for almost all use cases. Producers MAY allow consumers to configure this.

Producers SHOULD handle timeouts in the same way as `429 Too Many Requests` errors.

==== Retries

Webhooks are inherently unreliable. Network issues, server outages, misconfigurations, bugs, and all sorts of other problems can lead to webhook messages getting delayed or lost. It is therefore RECOMMENDED that webhook systems have retry mechanisms to improve the chances of successful delivery.

Retry delivery SHOULD follow a schedule spanning multiple days, with exponential back-off. The purpose of exponential back-off is to reduce the risk of a "thundering herd" of requests hitting a consumer system just as it recovers from a failure mode, risking pushing it offline again.

Below is a reasonable default retry schedule, but producers SHOULD adjust this as appropriate fr their use case. In addition, consumers SHOULD be able to configure their own retry schedule, overriding the producer's default configuration. Alternatively, consumer systems MAY respond with a `503 Service Unavailable` status and a `Retry-After` header field, which producer's SHOULD take into account when scheduling the next attempt.

|===
|Attempt |Delay since previous attempt |Cumulative delay
|1       |immediate                    |00:00:00
|2       |5 seconds                    |00:00:05
|3       |5 minutes                    |00:05:05
|4       |30 minutes                   |00:35:05
|5       |2 hours                      |02:35:05
|6       |5 hours                      |07:35:05
|7       |10 hours                     |17:35:05
|8       |14 hours                     |31:35:05
|9       |20 hours                     |51:35:05
|10      |24 hours                     |75:35:05
|===

In addition, producers MAY add some random jitter to retry intervals. This will help to spread out the load on consumer systems when they recover from a failure mode, and so reduce the risk of further failures being caused by the retry attempts themselves overloading the system.

If webhook delivery fails beyond the last retry attempt, consumers SHOULD be notified of the failure via other channels, such as email or SMS. After the last retry attempt, the consumer's webhook endpoint SHOULD be disabled in the producer's configuration, and further messages SHOULD NOT be sent until the consumer requests that the webhook endpoint be re-enabled.

==== Other considerations

Producers MUST NOT batch process the delivery of webhook messages, to avoid overloading consumer systems.

=== Webhook endpoint verification

Consumers MUST NOT be able to configure any arbitrary webhook endpoint URLs. This is a significant security risk for the producer, exposing them to server-side request forgery (SSRF) exploits. This is where URLs are set to internal network resources – eg. `http://localhost:8080` or `http://192.168.1.1` – or to cloud metadata endpoints – eg. `http://169.254.169.254/latest/meta-data/` – which may provide attackers with routes into the producer's private networks, internal services, and sensitive information that is not meant to be externally accessible.

At the very least, on registration of new webhook endpoint URLs, the URLs MUST be validated to ensure they are public internet addresses, and not "localhost" or IP addresses within the ranges reserved for internal networks. Producers can further protect themselves against SSRF by using a proxy (like smokescreen) to filter out requests to internal IP addresses, and by putting webhook workers (or the proxy) in their own private subnet that can't access internal services.

In addition, it is RECOMMENDED to implement a challenge-response system. When a new webhook URL is registered, a "challenge" token is sent to the webhook endpoint, which is expected to returna  valid response with the challenge token encoded somewhere in the response message. This verifies that the endpoint is reachable, and producers can use the process to verify things like the validity of the TLS certificate of the consumer service.

For the best security, domain name _ownership_ SHOULD be verified, too. This can be done using DNS lookups. The process usually involves the domain owner adding a TXT record to the domain's DNS settings, which the producer can then look up (once propagated) to verify ownership. A slightly weaker solution is verification of an email address hosted on the same domain.

Ideally, domain names would be human-moderated, too. The purpose is to prevent malicious actors from registering fake endpoints that pass all the automated verification checks.

Finally, producers SHOULD implement automated health checks on their consumers' webhook endpoints. Optionally, to protect against domain hijacking, producers MAY require consumers to revalidate the ownership of their domain names periodically.

=== Webhook management

Due to their inherent unreliability, webhooks should be treated as an optional convenience tool that sits alongside a regular HTTP API (or other web service). Consumers SHOULD NOT depend on webhooks alone to synchronize their state, or to otherwise integrate successfully, with the producer service. This means that consumers SHOULD be able to retrieve everything they need by polling the producer's API in the normal way.

Webhooks SHOULD be treated like a subscription service, in which consumers explicitly opt-in (via HTTP API endpoints) to receive notifications of particular event types. Consumers SHOULD NOT be burdened with needing to handle webhook messages they're not interested in.

.Example endpoints to manage webhook subscriptions
|===
|Method |Path |Description

|`GET`
|`/webhook/types`
|Retrieve a list of all available event types that can be subscribed to.

|`GET`
|`/webhook/subscriptions`
|Retrieve a list of all active webhook subscriptions for the consumer.

|`POST`
|`/webhook/subscriptions`
|Create a new webhook subscription for the consumer.

|`DELETE`
|`/webhook/subscriptions/{id}`
|Delete an existing webhook subscription for the consumer.
|===

Outbound webhooks MUST be disabled by default for each customer/user. Consumers MUST explicitly enable webhooks, and configure the event types they wish to receive, before any webhook messages are sent to them.

For some event types, webhook notifications MAY be delivered alongside other notification channels such as email or SMS. This is RECOMMENDED for security notifications and alerts, for example.

Consumers SHOULD be able to manage the configuration of their webhook messages, and other notification channels, in an automated way – ideally via an API, GUI, or both. Configurations that consumers SHOULD be able to control include, but are not limited to:

* Webhook endpoint URLs.
* Retry policies.
* Rate limits and back-off exponents.
* Signature scheme, if the producer offers both symmetric and asymmetric signatures.
* Key invalidation and rotation.
* Event types.
* Expiration times (when consumers want to automatically stop receiving webhook messages).
* The quantity of data communicated ("thin" versus "fat" payloads).

In addition, through the webhook management tools, consumers SHOULD be able to initiate retries of failed messages, and even replays of successful ones. Messages should be available for replay for a reasonable period of time, such as 30 days, after their initial delivery and before they are deleted permanently. This gives consumers plenty of time to recover from long outages without missing messages.

Consumers SHOULD be able to read and query their webhook message history, including failed deliveries ("dead letters"), via regular HTTP API endpoints and/or via a GUI dashboard. For full visibility, consumers should be able to inspect the reasons why webhook messages were deemed to have failed.

Producers SHOULD offer monitoring and alerting solutions for their consumers, so they can be notified early of problems delivering messages to their webhook endpoints.

Consumers MAY be able to define multiple webhook endpoints, supporting fan-out message distribution. This can be required for a number of reasons. It allows different consumer systems to process the same events in different ways. For example, when a payment is successfully completed, a customer may want their user management system, their CRM, and their internal team communication tool to be notified. Fan-out webhook messages also help to support platform migrations.

Where fan-out message distribution is supported, consumers MUST be able to configure each webhook endpoint independently, including different event types, retry policies, and potentially even things like signature schemes and verification secrets.

=== Documentation

It is RECOMMENDED that producers document their outbound webhook message formats and payload schema in a dedicated section of their regular API documentation.

https://www.asyncapi.com/[AsyncAPI] is an interface definition language for specifying asynchronous (eg. event-driven) APIs, and is therefore well-suited to webhooks. The more ubiquitous https://www.openapis.org/[OpenAPI], which was originally designed for synchronous HTTP APIs, has recently added support (since v3.1) for the definition of webhook payload schema (but not other aspects of webhooks such as signature schemes).

[source,yaml]
----
openapi: 3.1.0
info:
  title: My API
  version: 1.0.0

webhooks:
  orderPaid:
    post:
      summary: Order payment completed
      description: Triggered when a customer payment is processed
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderPaidEvent'
      responses:
        '200':
          description: Webhook received successfully
        '500':
          description: Webhook processing failed

components:
  schemas:
    OrderPaidEvent:
      type: object
      required: [eventId, eventType, timestamp, data]
      properties:
        eventId:
          type: string
          format: uuid
        eventType:
          type: string
          enum: [order.paid]
        timestamp:
          type: string
          format: date-time
        data:
          $ref: '#/components/schemas/OrderData'
----

As well as a formal specification of the data structures (eg. using JSON Schema or OpenAPI) it is RECOMMENDED to provide examples of the payload structure for each event type.

https://www.eventcatalog.dev/[Event Catalog] is another useful tool for documenting message-driven systems, though it is intended for internal communication patterns rather than public APIs.

=== Integration testing

Producers MUST offer endpoints through which consumers can trigger *test messages*, to verify their integration is working correctly.

=== SDKs

Producers MAY provide SDKs (software development kits) in popular programming languages, to help consumers implement webhook integrations more easily.

Basic SDKs SHOULD include functions that abstract away the complexity of verifying message signatures.

== References

* https://www.standardwebhooks.com/[Standard Webhooks] — A well-designed standard for webhook implementation, drawing on industry best practices.

* https://cloudevents.io/[CloudEvents] and the https://github.com/cloudevents/spec/blob/main/cloudevents/http-webhook.md[CloudEvents Web Hooks for Event Delivery] specification — CloudEvents is a specification for describing event data in a common way. It focuses on the event format (the payload) rather than other concerns such as the transport and authentication mechanisms.

* https://openid.net/wg/sharedsignals/[Shared Signals Framework (SSF)] — This OpenID Foundation initiative is effectively a standard for generalized webhooks. The framework defines stream-based communication mechanisms between "transmitters" (that generate events) and "receivers" (that consume them). It specifies event types, verification mechanisms, and transport protocols. It is part of a suite of standards under the OpenID umbrella, this standard focusing on the secure communication of security-related events. There are some useful security guidelines herein.

* https://web.archive.org/web/20220914184737/http://resthooks.org/[RestHooks] (https://github.com/zapier/resthooks[repository]) — An earlier standardization effort by Zapier, now inactive.

* https://datatracker.ietf.org/doc/rfc9421/[RFC 9421: HTTP Message Signatures] — If you prefer a standard solution to create, encode, and verify HTTP message signatures, look to this IETF RFC. https://httpsig.org/[httpsig.org] is an online sandbox to try out HTTP Message Signatures interactively, plus links to implementations in multiple programming languages.

* https://webhooks.fyi/[webhooks.fyi] — Not a standardization effort, but a useful community-maintained collection of resources about webhooks.

* https://medium.com/prospa-technology/webhooks-done-right-676d4e74578a[Webhooks done right], Amir Chatrbahr (2020)

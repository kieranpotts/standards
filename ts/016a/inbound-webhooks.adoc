= Inbound webhooks

When implementing inbound webhooks as a consumer, the main design consideration is the URL scheme, which is normally the only thing that you have any control over. The upstream service that produces the events will dictate things like the payload schema and the authentication method that your webhook endpoints will be required to support.

== URL schemes

The URL scheme for inbound webhooks MUST be distinct from the endpoints of the service's own HTTP API (if it has one). The aim is to avoid conflicts and allow the webhook endpoints to evolve independently of the main API endpoints.

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/_webhooks/{party}/{namespace}/v{version}/{event_type}/{...}
----

Where:

* `{party}` is the name of the third-party service (an event producer) that sends events to the endpoint. This is REQUIRED.

* `{namespace}` is an OPTIONAL path component used to scope a webhook to a particular service of the third-party event producer. This is required if a third-party offers multiple services, each of which emits events in different formats, and which therefore require differential handling by consumers.

* `{version}` is an OPTIONAL path component that identifies the version number of the event producer's webhook API or event schema that is supported by the endpoint. This can be omitted if the endpoint is designed to handle multiple versions of the producer's event schema in a backward-compatible way.

* `{event_type}` is an OPTIONAL path component that identifies a particular type of event that the endpoint is designed to receive. Normally, a single webhook endpoint is sufficient to handle all events from a particular producer. However, there may be cases where it is beneficial to have multiple webhook endpoints for the same producer, each tailored to specific event types or processing requirements. If this is not required, this path component MAY be omitted, or it MAY be the word "callback".

* `{...}` refers to any additional URL path components that are required by the event producer, for example for the purpose of passing resource identifiers.

The initial `/_webhooks/` path component is RECOMMENDED to clearly differentiate webhook endpoints from the main API endpoints of the service. The underscore prefix indicates that these endpoints are for internal use and are not part of the public HTTP API of the service. This path naming convention may also make it easier to differentiate cross-cutting concerns such as security policies, routing rules, monitoring, and logging configurations for webhook endpoints.

Consider the following examples of webhook URLs, which use the above scheme:

* `/_webhooks/authentiq/v3/callback`
* `/_webhooks/true-id/callback`
* `/_webhooks/transactify/v1/transaction-initiated`
* `/_webhooks/transactify/v1/transaction-complete`
* `/_webhooks/transactify/v2/transaction-initiated`
* `/_webhooks/transactify/v2/transaction-complete`

This fictional service exposes six webhook endpoints, which are used to receive notifications from three third-party event providers:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this producer. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* There's a similar webhook for a service called TrueID. This endpoint is not versioned, which means it could handle multiple versions of TrueID's webhook event schema if needed. We're pretending that this is an older identity verification service that is being phased out, to be replaced by AuthentiQ. In this transition phase, the system needs to support both producers – TrueID and AuthentiQ – in parallel. This demonstrates that this URL scheme supports zero-downtime transitions to alternative service providers.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

This webhook URL scheme supports multiple event producers. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. The URL scheme also makes it possible to incrementally transition from one service provider to another, eg. swapping the payment service gateway, without breaking your own service.

== Versioning

The `{version}` component in the URL scheme is independent of the versioning scheme for the consumer's own HTTP API (if it has one). It may vary between webhook endpoints, too.

In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhook endpoints are different. These are scoped to the versions of the message schema that producers send to the webhook endpoints. Since it is the event producer that specifies the interface contract for its webhooks – the HTTP methods, payload structures, authentication mechanisms, and so on – then the `{version}` value is determined by them.

By including the message scheme version in their webhook URL schemes, consumers can incrementally transition to new breaking-change schemas without breaking their own services. During these transition periods, consumers might have duplicate webhook endpoints, like this:

* `/_webhooks/{party}/v3/receive-event`
* `/_webhooks/{party}/v4/receive-event`

[TIP]
======
If a producer does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the producer's own web service API. If this is not possible either, you can invent your own versioning system for the producer. This could be as simple as using the terms "latest" and "next" for the `{version}` path component.
======

== Timeouts

Producers of webhook events MAY impose timeouts on how long they will wait for a response from the consumer's webhook endpoint. If the consumer does not respond within the timeout period, the producer MAY retry sending the event message, or it MAY discard it.

The timeout period is normally specified in the producer's documentation. This is usually quite short, typically 15 to 30 seconds. If the producer does not specify a timeout period, then it is RECOMMENDED to assume a timeout of 10 seconds.

Due to the potentially high latency of network communication, and the variable load on the consumer's servers, it is RECOMMENDED that webhook endpoints be designed to handle messages asynchronously. This means that the consumer should log messages on a queue, to be processed later, and return success status codes quickly, without waiting for the messages to be processes.

== Status codes

When integrating with third-party services via inbound webhooks, those third-party services may require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the producer specifies the status codes that it expects in response, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular response codes from your consumer service.

But if a producer does not specify the status codes that it expects, then follow these best practices...

It is RECOMMENDED to return a `202 Accepted` for all success scenarios. This code indicates that the event has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook event receipts, as it allows the recipient to process the request asynchronously.

To indicate errors, if the producer does not specify what error codes it expects, then the following response codes are RECOMMENDED:

* `400 Bad Request` for client errors, which you should return when an event message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization checks (permissions, scopes).
* `404 Not Found` when the webhook endpoint does not exist, for example it has been deprecated or moved.
* `429 Too Many Requests` when rate limits have been exceeded.
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5xx` code, you are basically saying to the client "please retry this later".

= TS-16: HTTP APIs
:toc: macro
:toc-title: Contents

This document outlines standards for designing and implementing HTTP APIs. It also covers best practices for the implementation of webhooks (both inbound and outbound).

These standards are applicable to both private HTTP APIs between services within distributed software systems ("inter-service communication") and to public HTTP APIs that are made available for integration into third-party client applications ("web services").

In this technical standard, URLs containing variables are specified according to https://tools.ietf.org/html/rfc6570[IETF RFC 6570: URI Template]. For example, a URL containing a variable called `account_id` would be shown as `api.example.com/v1/accounts/{account_id}`.

toc::[]

== General design principles

HTTP APIs, both public and private ones, SHOULD be formed from a consistent set of design patterns – a pattern library. This facilitates a better developer experience and supports greater reuse of code, for example through libraries and software development kits (SDKs), so making integrations quicker and easier.

In broad terms, HTTP APIs SHOULD follow the https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm[RESTful architectural style]. This architecture describes the underlying design principles of the World Wide Web, particularly the HTTP protocol and HTML language. In practice, a RESTful API is one that repurposes the semantics of the HTTP protocol, using the full capabilities of HTTP as a messaging and encoding protocol, rather than merely as a transport protocol. In simple terms, a RESTful API uses URLs to represent resources and collections of resources, HTTP methods to represent different types of CRUD-like operations to be performed on those resources, and HTTP status codes to represent outcomes from those operations.

A RESTful API is also:

* *Stateless*: Each request from a client to a server SHOULD contain all the information necessary for the server to understand and fulfil the request. Most client requests SHOULD NOT be dependent upon any particular stored context on the server (with exceptions for things like security measures, eg. to protect against denial of service). This design constraint will simplify the server implementation and make it more scalable.

* *Uniform*: A RESTful API SHOULD have a highly uniform interface, which means it uses a consistent subset of HTTP methods and status codes, uses a consistent file format and schema for message payloads, composes data structures from a common library of types, and uses a consistent URL structure to represent resources and collections. This constraint will help to simplify client implementations, promote code reuse, and make integrations easier.

* *Cacheable*: As much as possible, responses from a RESTful API server SHOULD be cacheable. This helps to reduce load on the server, reduces latency for clients, and supports strategies for fault tolerance and availability.

* *A layered system*: The server application SHOULD have a layered architecture, in which cross-cutting concerns such as security and caching are implemented in discrete layers that span all endpoints of the API.

The following RESTful design constraints are OPTIONAL:

* *Hypermedia as the engine of application state (HATEOAS)*: HTTP APIs MAY embed hypermedia links through which clients can explore the available resources and operations of the API. Clients MAY use the encoded hypermedia controls to read, query, and update application state. This design constraint is not commonly used in practice, but it can be beneficial for some use cases. HATEOAS may be appropriate for APIs that are intended to be consumed directly by human users, who interact with the API through a generic program to explore the available resources and operations, which themselves are constantly evolving. HATEOAS is less useful for APIs that are intended for programmatic integration into other computer systems.

* *Code on demand*: The server MAY send executable code to the client, to extend the functionality of the client. Again, this design constraint is not commonly used in practice, but one possible use case would be for an API to serve updates to SDKs, written in various programming languages, that are dynamically integrated into client applications.

Although most HTTP APIs should be primarily RESTful, or resource-oriented, there are many use cases where a RESTful design is not appropriate. For example, if an API is a thin layer around a legacy system that itself is not designed around resources or which fits uncomfortably with the RESTful model, it may be necessary to deviate from RESTful design principles and focus on creating a functional abstraction of the underlying system.

Even within an HTTP API that is predominantly RESTful in its design characteristics, it will often be beneficial to include operations that are more RPC-like in their design. For example, besides the usual create, read, update, and delete operations that are made available on a collection of resources, an HTTP API may augment these operations with additional "actions" that perform tasks on the resources that do not neatly fit the CRUD model, or which abstract multiple CRUD-like operations in a single request. See the section on *Actions* for more information.

In designing an HTTP API, developers SHOULD prioritize creating an accurate model of the system that the API abstracts, rather than trying to religiously adhere to any particular architectural style. Remember, the goal of an HTTP API is to provide a useful and usable interface to a complex system. The best API design will be the one that makes it as easy as possible for clients to interact with the underlying system.

== Authentication and authorization

Authentication and authorization MUST be implemented for all HTTP APIs, including private (internal network) HTTP APIs.

Authentication and authorization is especially important for operations that modify data.

// TODO: Extend with recommended auth systems, JWTs, etc.

== Security

Security measures MUST be implemented for both public and private APIs. Do not assume that private/internal networks are secure.

All input MUST be validated and sanitized to prevent security vulnerabilities such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF).

// TODO: Extend with recommended security practices, OWASP, etc. Or link to other standards.

== HTTP methods

HTTP methods define actions to be performed on a resource or a collection of resources.

HTTP methods MUST be used for their designated purpose, as specified by the HTTP standards. This will make it much easier for client applications to be integrated with the API.

HTTP APIs MUST use only the following subset of standard HTTP methods:

|===
|Verb |CRUD mapping |Description

|GET
|Read
|Used to retrieve the requested resource. GET operations MUST NOT modify the state of the resource, and there MUST NOT be any other side effects.

|HEAD
|Read
|Used to retrieve only the headers of a resource – it behaves the same as GET but excluding the body from response messages.

|POST
|Create
|Used to create a new resource. The server MUST generate a new resource identifier. The server MUST return a full representation of the newly created resource, including its new identifier and other server-generated properties.

|PUT
|Create/Update
|Used to fully replace a resource with the request payload, or to create a new resource in scenarios where the client takes over responsibility from the server for generating a unique identifier for the resource.

|PATCH
|Update
|Used for partial updates to a resource. The request payload SHOULD contain only the fields that are being updated.

|DELETE
|Delete
|Used to delete a resource. Should be repeatable, always with a positive response even if the resource is already deleted.
|===

.GET versus HEAD
****
It is RECOMMENDED that all GET endpoints – for both resources and collections – in an HTTP API also support HEAD requests. HEAD responses are identical to GET responses, except that the server MUST NOT return a message body in the response. This can be useful for clients that need to check the existence of a resource without downloading the full representation.
****

Other standard HTTP methods are `OPTIONS`, `TRACE`, and `CONNECT`. These are technical methods used to support the HTTP protocol itself, and are not intended the be included in the interface definitions for HTTP APIs.

Most HTTP API operations are implemented as synchronous operations, in which the client sends a request and waits for an immediate response from the server. However, where operations may be long-running, it is RECOMMENDED to implement the operations using asynchronous communication patterns. The behavior of the HTTP methods, listed above, is identical for asynchronous communication, the difference being that the response status code and payload is delivered subsequently via a separate message.

== HTTP status codes

Appropriate HTTP response codes MUST be used in response messages to indicate the result of API requests. Using the correct codes in responses is not just about adhering to the HTTP protocol, but also about facilitating the correct interpretation of HTTP responses by clients.

There are many standardized HTTP status codes. Most APIs will need only a subset of the full set of standard codes. The supported subset of HTTP status codes MUST be documented as part of the API's interface definition. Commonly-used status codes include:

* *1xx*: Informational response codes.

  ** `100 Continue`: Indicates that the initial part of the request has been received and the client should continue sending the rest of the request. This is used in the context of large payloads that cannot reasonably be transmitted in a single message.

* *2xx*: Success response codes.

  ** `200 OK`: Indicates that the request was successful. This is the most widely-used success response code.

  ** `201 Created`: Indicates that the request was successful and, as a result, a new resource has been created.

  ** `202 Accepted`: For asynchronous operations that will be fulfilled by the server at a later time. This signifies that the server has received the message, and has added it to a queue for processing. The outcome of that processing (whether successful or unsuccessful) is not yet known, therefore.

  ** `204 No Content`: Indicates that the request was successful but there is no content to return in the response message. This status code MUST be returned with an empty HTTP message body.

* *3xx*: Redirection response codes.

  ** `301 Moved Permanently`: Indicates that the requested URL has been changed permanently. The new URL MUST be specified in the response.

  ** `302 Found`: Indicates that the requested resource is temporarily under a different URL.

* *4xx*: Client error response codes.

  ** `400 Bad Request`: Indicates that the request cannot be understood or processed by the server due to a syntax error in the client's request message.

  ** `401 Unauthorized`: Indicates that the request requires authentication but the client has not authenticated itself.

  ** `403 Forbidden`: Indicates that the server understood the request but is refusing to authorize access to the specific resource or operation requested.

  ** `404 Not Found`: Indicates that the server could not find the requested resource.

  ** `405 Method Not Allowed`: Indicates that the HTTP method used in the request is not allowed on the target resource (but the resource exists and other methods can be run on it).

* *5xx*: Server error response codes.

  ** `500 Internal Server Error`: Indicates that the server encountered a situation it doesn't know how to handle.

  ** `502 Bad Gateway`: Indicates that the server, while acting as a gateway or proxy, received an invalid response from an upstream server.

  ** `503 Service Unavailable`: Indicates that the server is not ready to handle the request, typically due to maintenance or overload.

== URLs

URLs identify resources, collections of resources, and actions.

=== Path delimiters

The forward slash (`/`) character is used to delimit between path segments in URLs.

API documentation SHOULD be consistent in its use of trailing slashes. It is RECOMMENDED that trailing slashes be omitted in documentation. However, an API SHOULD accept requests with or without a trailing slash, but SHOULD NOT respond with a redirect to the canonical version.

.Postel's Law (aka. the Robustness Principle)
****
Be liberal in what you accept, and conservative in what you send.
****

=== Versioning

HTTP APIs MUST be versioned, and version information SHOULD be encoded in the URL path. This pattern is widely used for its simplicity of use by clients and compatibility with caching and proxying systems (compared to alternative designs such as header-based versioning).

HTTP APIs MUST use https://semver.org/[Semantic Versioning], as specified in *link:./005-versioning.adoc[TS-5: Versioning]*. However, only the major version number needs to be exposed in the URL schema.

It is RECOMMENDED that the major version number be the first segment of the URL path, eg. `/v1`. This tends to make it easier for clients to implement version-specific behavior, and it also tends to make it easier to maintain and deploy multiple major versions of an API in parallel on the server side.

.Template
----
/v{major}
----

.Example
----
/v1
----

See the *Versioning* section, below, for more guidance on HTTP API versioning.

=== Namespaces

The next part of the URL path SHOULD be treated as a "namespace" in which related resources will be grouped.

Namespaces are used to create logical groups of resources, collections, and actions. But they do not necessarily map directly to modules or back-end services that are responsible for fulfilling requests. Namespaces SHOULD reflect the customer's perspective of how the product works. That perspective may not necessarily reflect the internal structure of the system, or the business domains and subdomains.

.Template
----
/v{major}/{namespace}
----

.Example
----
/v1/vault
----

Namespaces SHOULD be nouns but MAY be either singular or plural, as appropriate for each grouping of resources, collections, and actions.

A good practice is to open a `GET` endpoint for the namespace root, which returns a list of availabel resources and corresponding operations within the namespace.

----
GET /v{major}/{namespace}
----

=== Resources and collections

The remaining segments of a URL path are used to identify resources and collections of resources,

Consistent path components SHOULD be used to refer to the same resources, and collections of them, across different endpoints.

.Templates
----
GET /v{major}/{namespace}/{resource}
GET /v{major}/{namespace}/{resource}/{resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}
----

Sub-resources and sub-collections MAY be supported, too.

.Templates
----
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
----

The `{resource}` and `{sub_resource}` components SHOULD be named using nouns. These SHOULD be in the singular form where there is only ever one instance of the resource, and never a collection of resources of the same type. More commonly, there will be collections of each type of resource and sub-resource, and these SHOULD be named in the plural form.

Resource-oriented endpoints SHOULD use lowercase hyphen-delimited slugs to name resources and sub-resources. Examples: "account", "users", "billing", "charge-points", "charge-points/{charge_point_id}/sessions", "credit-cards", "credit-cards/{credit_card_id}/transactions".

== Collections

A collection is a list of multiple resources of the same type, plus any related metadata.

Collections, and the resources they encapsulate, SHOULD be named consistently across different endpoints. This allows clients to implement generic data access handling.

The resource representations returned in collections MAY be only partial representations of the full resources. It MAY be necessary for clients to subsequently fetch individual resources to retrieve their full representations.

.Template
----
GET /v{major}/{namespace}/{resource}
----

.Example
----
GET /v1/vault/credit-cards
----

// TODO: Update to match standard schema.
.Example response
----
{
  "metadata": {
    "total_items": 1,
    "total_pages": 1
  },
  "items": [
    {
      "data": {
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "type": "visa",
        "number": "xxxxxxxxxxxx0331",
        "expires": {
          "month": "11",
          "year": "2018",
        },
        "name": {
          "first": "Joe",
          "last": "Shopper"
        }
      },
      "metadata": {
        "create_time": "2014-01-13T07:23:15Z",
        "update_time": "2014-01-13T07:23:15Z",
      },
      "links": [
        {
          "rel": "self",
          "method": "GET"
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        },
        {
          "rel": "delete",
          "method": "DELETE",
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        },
        {
          "rel": "patch",
          "method": "PATCH",
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        }
      ]
    }
  ],
  "links": [
    {
      "rel": "self",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards?page=3&per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "prev",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=2&per_page=10&sort_by=create_time&sort_order=asc
    },
    {
      "rel": "next",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=4&per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "first",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "last",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=123&per_page=10&sort_by=create_time&sort_order=asc"
    }
  ]
}
----

=== Pagination

Any collection that could contain a large, potentially unbounded list of resources SHOULD implement pagination. The following design patterns are RECOMMENDED.

----
/accounts?per_page={per_page}&page={page}
----

Pages of results SHOULD be referred to consistently by the query parameters `page` and `per_page`, where `per_page` is a non-zero positive integer representing the number of results per paginated response, and `page` is a number of 1 or more that represents the current page of results requested.

The `per_page` query parameter SHOULD be optional. If not provided by the client, the server should fallback to a sensible, specified default.

The `page` query parameter SHOULD also be optional. If not provided by the client, the server MUST return the first page of results (ie. the default value for `page` MUST be 1).

The values of both `page` and `per_page` MUST be validated by the server. A `400 Bad Request` SHOULD be returned for semantically invalid values. However, if the requested range if outside of the available range of results (eg. `per_page=100&page=2` is requested but there are only 50 results) a `200 OK` response SHOULD be returned with an empty result list, not a `404 Not Found`.

In certain cases, such as querying on a large data set, in order to optimize the query execution with pagination, it may be appropriate to retrieve the data based on the result set of the previous page. A `page_token` parameter MAY be used for this purpose. This could be, for example, an encrypted value of primary keys to navigate to the next and previous pages, along with directions.

Additionally, responses MAY include `total_items` and `total_pages` metadata fields. `total_items` indicates the total number of items in the collection, and `total_pages` is the number of pages (interpolated from `total_items`/`per_page`). This will help clients to implement better user experiences, for example by disabling navigation to pages that are outside of the available range. Where providing the `total_items` and `total_pages` requires expensive queries on the server-side, the client SHOULD be able to opt-in to receiving this information using a query parameter, for example `?include_totals=true`.

Hypermedia links with `rel` attributes for "next", "previous", "first", and "last" pages SHOULD be included in paginated collections, to make it easier for clients to navigate through collections. The `page` and `per_page` query parameters, inputted by the client, MUST be maintained for each link, to ensure consistent client behavior. See the section on *Hypermedia* for more information.

=== Filtering

Collections MAY be filtered by default. For example, resources to which a user is not authorized to access MUST NOT be included in a collection. If all resources in a collection are not authorized, returning a `403 Forbidden` response would be appropriate.

Additional, optional filtering may be applied by clients using query parameters. For example, the following query parameters MAY be available for clients to filter collections by a time range:

* `start_time` or `{property_name}_after`: An ISO-8601 date and time string that represents the start of a temporal range. `start_time` may be used when there is only one unambiguous time dimension, otherwise the property name should be used, eg, `processed_after`, `uploaded_after`. The property SHOULD map to a time field in the representation.

* `end_time` or `{property_name}_before`: An ISO-8601 date and time string indicating the end of a temporal range. `end_time` may be used when there is only one unambiguous time dimension, otherwise the property name should be used, eg. `processed_before`, `uploaded_before`. The property SHOULD map to a time field in the representation.

These query parameters SHOULD be used consistently across all endpoints that support time-based filtering.

=== Searching

Search query parameters MAY be supported on collections, to allow clients to filter collection lists based on freeform input. The query parameter SHOULD be named `q` and MAY be used to search across multiple fields of the resources.

=== Sorting

Results could be ordered according to sorting-related instructions given by the client. This includes sorting by a specific field's value, and sorting order.

The following URL parameters SHOULD be used for this purpose:

* `sort_by`: A dimension by which items should be sorted. The dimensions SHOULD be an attribute in the item's representation.

* `sort_order`: The order, one of "asc" or "desc", indicating ascending or descending order.

The default sort field and sort order MUST be documented for each collection. All collections have a default sorting, except in use cases where the order is deliberately randomized (if so, this still needs to be specified).

=== HTTP statuses

If a collection is empty (ie. it has zero items), returning `404 Not Found` is not appropriate. It was the collection that was requested, not a specific item in the collection. And the collection exists – it is just empty. So logically it makes sense to return a `200 OK` response with an empty `items` array.

Invalid query parameters SHOULD be signalled with a `404 Bad Request` response.

== Resources

=== Reading

Single resources are typically discovered through a collection, and are identified by a unique identifier. When reading single resources, a more detailed representation of the resource MAY be returned than the default, minimized representations included in collections.

A resource's unique identifier SHOULD be unique to all resources of all types, not only resources of the same type or in the same collection. UUIDs are RECOMMENDED for this purpose, as each generated UUID is more-or-less guaranteed to be unique globally.

Identifiers for sensitive data SHOULD be non-sequential, and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers SHOULD be used for readability and debugging.

If the provided resource identifier is not found, even if the data is "soft deleted" in the data source, the response status code should be `404 Not Found`. Otherwise, `200 OK` MUST be returned when the resource is found.

.Template
----
GET /v{major}/{namespace}/{resource}/{resource_id}
----

.Example
----
GET /v1/vault/customers/123e4567-e89b-12d3-a456-426614174000
----

=== Updating

There are two ways to update resources:

* Using `PUT` to fully replace the resource.
* Using `PATCH` to partially update the resource.

In both cases, the shape of the input data SHOULD be consistent with the shape of the resource representation returned by the API via the corresponding GET requests. The only difference is that `PATCH` may submit fewer fields – essentially a diff of what's changed since the last `GET`.

For `PUT` requests, system-calculated values such as `create_time` and `update_time` SHOULD be optional and SHOULD be ignored on deserialization by the server. For `PATCH` requests, clients SHOULD be expected to omit these fields from the request body, and the server SHOULD return `400 Bad Request` if they are included. For `PATCH` requests, the client is expected to submit only the fields that have been updated by the client, and since the client cannot update system-calculated values, trying to do so should be treated as a client error.

.Template
----
PUT|PATCH /v{major}/{namespace}/{resource}/{resource_id}
----

Alternatively, standards such as https://datatracker.ietf.org/doc/html/rfc6902[JSON Patch] MAY be implemented for https://tools.ietf.org/html/rfc5789[PATCH] requests. Rather than sending a partial representation of the resource, clients instead send a list of operations to be made on particular members or fields of the resource.

[source,http]
----
PATCH /widgets/abc123 HTTP/1.1
Host: api.example.com
Content-Length: ...
Content-Type: application/json-patch

[
  {
    "op": "replace",
    "path": "/a/b/c",
    "value": 42
  },
  {
    "op": "remove",
    "path": "/a/b/c"
  },
  {
    "op": "move",
    "from": "/a/b/c",
    "path": "/a/b/d"
  }
]
----

The value of the "path" field is a https://tools.ietf.org/html/rfc6901[JSON Pointer] that references the location within the target document where the operation is to be performed. For example, the path `/a/b/c` refers to the element "c" in the below JSON:

[source,json]
----
{
  "a": {
    "b": {
      "c": "",
      "d": ""
    },
    "e": ""
  }
}
----

The supported operations are "add", "remove", "replace", "move", "copy", and "test". To support partial updates to fixed-schema resources, APIs need to support only "add", "remove", and "replace" operations.

After a successful update operation, both `PUT` and `PATCH` operations SHOULD normally respond with `204 No Content` status, with no accompanying response body. However, there may be use cases where it is preferable to instead return `200 OK` with an updated resource in the response body. For example, this may be required where clients need updates to system-calculated fields, or otherwise to optimize client-server interactions. Alternatively, clients may opt-in to receiving a `200 OK` response with a response body by including the request header `Prefer:return=representation`.

Any update request (whether PUT or PATCH) that fails input validation MUST receive a `400 Bad Request` response. If clients attempt to modify read-only fields, or if the resource is in a non-updatable state, this is also a `400 Bad Request`. If there are business rules or validation constraints, eg. for data type, length, etc., that are not satisfied, a `400 Bad Request` response is appropriate. In addition, appropriate error codes and messages SHOULD be encoded in the response body.

For situations that require interaction with downstream servers or external APIs or processes, returning the `422 Unprocessable Entity` status code may be more appropriate than `400 Bad Request`.

=== Deleting

In order to enable retries (eg. due to patchy connectivity), and for conformance with HTTP standards, `DELETE` operations MUST be implemented to be idempotent. This means that successful `DELETE` operations MUST always respond with `204 No Content`, even if the resource is already deleted. Returning `404 Not Found` is not appropriate for `DELETE` operations in this scenario, as it suggests that the resource never existed at all. If necessary, clients can use `GET` to verify the resource exists prior to `DELETE`.

.Template
----
DELETE /v{major}/{namespace}/{resource}/{resource_id}
----

There may be use cases where a client expects resources to exist but they unexpectedly disappear. This could be because a resource expired, or because of some policy, such as a data retention operation that cleans-up stale data. In these use cases, services MAY return a `410 Gone` error code in response to a request for a resource that no longer exists. Doing so provides the client with extra information (it tells the client that the resource had already been deleted).

For historical reasons, many web servers and HTTP client libraries do not expect a message body to be included in HTTP messages sent using the `DELETE` method. To support the widest possible range of clients, it remains good practice to _not_ require DELETE requests to be accompanied by a payload. This is an OPTIONAL constraint, and is only REQUIRED if there are known to be clients that will be unable to support DELETE requests with payloads.

=== Creating

There are two ways to create resources:

* Using `POST` to create a resource but have the server create an identifier for it.
* Using `PUT` to create a full resource, including a unique identifier that is generated client-side.

.Template
----
POST|PUT /v{major}/{namespace}/{resource}/{resource_id}
----

`PUT` operations are idempotent by default, because the request payload has a built-in unique identifier in the form of the resource ID, generated by the client.

`POST` operations are NOT idempotent by default, and therefore there is risk that duplicates of the same resource may be created if the client retries a `POST` request. Where it is necessary to prevent this, clients MUST include a unique identifier for the _request_ message (eg. `request_id`). The server will use the request ID to make sure it processes only the first instance that it receives of each distinct request.

For `PUT` requests, system-calculated values – and other read-only fields – such as `create_time` and `update_time` SHOULD be made optional and SHOULD be ignored on deserialization by the server. But for `POST` requests, clients SHOULD be expected to omit these fields from the request body, and therefore the server SHOULD return `400 Bad Request` when such fields are included in the request content.

Otherwise, both operations SHOULD behave in the same way. Both `POST` and `PUT` payloads MAY include only a subset of input fields (only the required fields, for example), with the server filling in optional fields with default values.

The number of required fields SHOULD be minimized as much as possible. Implement as many default/fallback values as can reasonably be applied for each business case.

For both `POST` and `PUT` creation operations, successful outcomes MUST be signalled by a `201 Created` response, and a representation of the created resource MUST be returned in the response body – including any server-generated fields such as `create_time`.

Response messages SHOULD include a list of hypermedia links that represent all the available operations that can be performed on the newly-created resource. For example, if only `GET` and `DELETE` operations are available:

.Example response
----
{
  "data": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "type": "visa",
    "number": "xxxxxxxxxxxx0331",
    "expire_month": "11",
    "expire_year": "2018",
    "first_name": "Joe",
    "last_name": "Shopper",
  },
  "links": [
    {
      "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000",
      "rel": "self",
      "method": "GET"
    },
    {
      "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000",
      "rel": "delete",
      "method": "DELETE"
    }
  ]
}
----

== Sub-resources and sub-collections

Sub-resources and sub-collections SHOULD be used sparingly and only where they are essential to expressing an accurate representation of an API's resource model.

.Templates
----
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
----

Where a resource of one type can exist independently of other resources of other types, these resources SHOULD be elevated to top-level resources in most use cases. But if one type of resource cannot exist without another, this is a candidate to be lowered to a sub-resource.

Sub-resources require multiple identifiers (*composite keys*, in database lexicon) to be uniquely identified. To identify a sub-resource, the parent resource's identifier is required, as well as the sub-resource's identifier. This is a potential source of complexity for client applications, as they need to manage multiple identifiers for essentially the same resource.

For this reason, sub-resources SHOULD be used sparingly. The need to encode hierarchies of resources can increase the complexity of both server-side and client-side code. So, even where there is a tight coupling between two types of resources, look to promoting dependent resources to top-level resources (with single identifiers) where practical.

Where sub-resources are necessary or beneficial, try to have no more than one level of sub-resources - that's two levels of resources in total. Any more levels, and the complexity of client application code grows exponentially. Server code, too, needs to validate each level of resources, including how sub-resources related to their parent resources, and this complexity also grows exponentially with each additional tier.

Sub-resources MUST have a named type. `/v{major}/{namespace}/{resource}/{resource_id}/{sub_resource_id}` is not acceptable because `sub_resource_id` has ambiguous meaning. Linking sub-resource identifiers to sub-resource types in the URL scheme also supports extensibility; other sub-resources can be more easily added in the future. This constraint also makes it easier to support different identifier naming conventions being used for different types of sub-resources, should that be necessary.

Sub-resources MAY be used as a solution to reducing the size of the parent resource, so segmenting a single large resource into multiple smaller resources. These types of sub-resources are known as *singleton sub-resources* and are identified by a static *sub-resource name* rather than a dynamically-generated identifier. Singleton sub-resources should be named using nouns in the singular form.

.Template
----
/v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_name}
----

.Example
----
GET /v1/customers/devices/123e4567-e89b-12d3-a456-426614174000/vendor-information
----

There will be a one-to-one relationship between a resource and each of its singleton sub-resources. Singleton sub-resources are expected to always exist if the parent resource exists, though they may have null values. (Do not return `404 Not Found` if a singleton sub-resource does not exist; simply return `null` for its value.)

Singleton sub-resources are not standalone resources, but are attached to their parent. Therefore, singleton sub-resources SHOULD be created and updated via the operations for their parent resource, rather than adding dedicated endpoints for them. Singleton sub-resources SHOULD NOT duplicate resources from other collections, but SHOULD be unique to their parent resource.

== Safeness and idempotency

The HTTP standards define the concepts of safeness and idempotency for HTTP methods.

A *safe* operation is one that does not modify the state of the resource. The HTTP standards define the `GET` and `HEAD` methods as safe methods, as these methods are intended not to request any kind of action other than data retrieval.

An *idempotent* operation is one that has the same effect on the state of the requested resources, regardless of how many times the operation is performed. Clients can therefore retry operations, sending identical requests multiple times, without worrying about data corruption or other unexpected side effects of doing the retries.

There are many use cases for clients to send identical requests multiple times. Commonly, this is done in retry mechanisms in response to failed connection attempts.

Building in idempotency is an important aspect of the design of any HTTP API. It makes it easier for clients to interact with the API, and improves the fault tolerance of the server-side system.

The HTTP standards define the `GET`, `HEAD`, `PUT`, and `DELETE` methods as being idempotent methods. HTTP APIs therefore MUST implement these operations to be idempotent.

The HTTP standards do not specify the `PATCH` method as being neither safe nor idempotent. However, it is strongly RECOMMENDED that `PATCH` operations be implemented as idempotent ones.

`POST` operations are, by definition, neither safe nor idempotent. By default, executing an identical `POST` operation multiple times will create multiple discrete resources with different identifiers but duplicate data. There may be legitimate use cases where this is the desirable behavior. For example, a "like" operation on a social media post may not be required to be idempotent, as the desired behavior of sending multiple instances of the same request may be to toggle the user's "like" state of the post.

However, for most use cases in most APIs it is expected that `POST` operations will need to be implemented to be idempotent, to avoid unwanted duplicates of data entities being created.

Idempotency keys MUST be used to implement idempotency in `POST`, `PUT`, `PATCH`, and `DELETE` operations as required. An idempotency key is generated client-side and it is a unique identifier for each discrete request. It is used by the server to ensure that it processes only the first instance of each discrete request it receives. Subsequent requests with the same idempotency key are ignored, and the _same response is returned as for the first request_ (the server should assume that the client never received the first response).

Idempotency keys have other use cases too. They can double up as identifiers to correlate requests with responses ("correlation IDs"), and they support the tracing of cause-and-effect throughout distributed systems ("trace IDs"). For this reason, it is RECOMMENDED that idempotency keys be implemented universally across all operations in an API, including `GET` and `HEAD` operations.

In HTTP APIs, the header field `X-Request-Id` SHOULD be used as the idempotency key. This is a widely-used header field, and it is used by many client libraries and frameworks to generate unique identifiers for requests.

[source,http]
----
POST /v1/payments/payouts HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer {token}
X-Request-Id: 123e4567-e89b-12d3-a456-426655440000

{
  // ...
}
----

If a `X-Request-Id` header is not provided by the client, the server MAY generate a unique identifier for the request. However, for most use cases it will be more appropriate for the service to respond with a `400 Bad Request` and a link to the relevant documentation.

Whether an idempotency key is generated client-side or server-side, it MUST be returned in response messages, also in the `X-Request-Id` header field.

Each idempotency key MUST be unique and MUST NOT be reused with other requests with different payloads. For simplicity of implementation, idempotency keys SHOULD be unique across all clients, too. For this reason, it is RECOMMENDED to use the UUID version 4 algorithm to generate idempotency keys. This probability of generating the same UUID twice is so low that it can be considered to be zero for all practical purposes.

If a client reused an idempotency key with a different request payload, the server MUST reply with a `422` status code.

To implement idempotency, servers are required to cache response payloads against their idempotency keys. The server MUST return the cached response payload for each subsequent request with the same idempotency key, even if the response status code is not `200 OK`. This is to ensure that the client receives the same response as it would have received if the request had not been retried.

Validity of idempotency keys SHOULD be time-based, allowing for servers to optimize storage by periodically purging the cached response payloads associated with expired idempotency keys (which are persisted for longer). The expiry time MAY vary depending on each key's use case, but a good default value is 24 hours. After this time, the server SHOULD return a `400 Bad Request` response for requests with expired idempotency keys.

== Actions

In a RESTful-style of HTTP API, endpoints are resource-oriented. CRUD-like operations are performed against individual resources, and collections of resources, of various types. Resources are typically a conceptual mapping to a set of entities in a domain system.

But some operations may not neatly fit into the RESTful model. It is sometimes quite difficult to model business processes in a pure RESTful service. Classic examples include endpoints to "login", "logout", "reset password", "charge a credit card", "resend a notification", and to "configure permissions and roles".

These standalone operations are referred to as "actions" in this technical standard. Elsewhere, they may be referred to by other names such as "controllers", "procedures", "operations", or simply "endpoints".

Actions tend to be mapped directly to specific controller methods in the server-side code, and for this reason they are the HTTP API equivalent of RPC (remote procedure call) protocols.

A common use case for actions is to mutate the state of multiple resources in the same operation. These are known as *composite actions*. There will often be business operations that are not scoped to any one particular entity in the domain model. These are candidates for modelling as composite actions. Composite actions are a pattern for combining multiple atomic operations in a single transaction, abstracting away complex, multi-step processes behind a convenient facade for the client, so simplifying client-server interactions.

An example would be a "refund" action that would change the state of a payment, the customer's account, and the merchant's account, and the action would not be considered to be fulfilled until all of these changes are committed. Another example of a composite action would be the implementation of a search function that operates across multiple resource types.

Composite actions may be implemented for both performance optimization and usability reasons.

Another use case for actions is to implement transient operations. A transient operation is one that does not mutate the state of any resources, or create new ones. An example might be a "dry run" action that validates the input data for a subsequent operation, such as a payment.

There are many other use cases for augmenting HTTP APIs, which are predominantly resource-oriented, with standalone RPC-like actions. You can think of actions as fulfilling a similar role to services in domain-driven design. In DDD, services are a pattern that encapsulate business logic that operates across multiple entities in a domain model. Similarly, actions trigger logic that doesn't obviously belong to any one resource and/or any one CRUD operation.

There are risks and benefits to using actions in HTTP APIs. Action-oriented APIs can be harder to scale than resource-oriented ones. The number of URLs can grow much more quickly, producing increased configuration complexity for routing and externalization, among other things. There tends also to be fewer opportunities to promote code reuse in automated tests (because actions tend to have greater variability in their inputs and outputs than operations performed on resources).

However, for most HTTP APIs, not everything fits neatly into the RESTful architectural style. Some operations are simply better expressed as actions.

The preference should be to design as much of an HTTP API as possible around a resource-oriented model, and augment the API with actions where specific operations do not fit neatly into that model. We should not try to force everything into the resource model just for the sake of purity of the API design.

=== Implementing actions

==== HTTP methods

Actions MUST be performed using HTTP's `POST` method, except for actions that retrieve read-only data such as logs or reports, in which case the `GET` method MUST be used – to provide opportunities for client-side caching (`POST` responses are not cacheable.)

==== URLs

The name of an action SHOULD suggest the type of CRUD operation to be performed, rather than this being baked into the semantics of the HTTP method. Because actions represent a processing function on the server side, it is usually more intuitive to express them using verbs such as "activate", "cancel", "validate", "accept", and "deny".

Action names should be like function names. Use lowerCamelCase with the first segment being a verb. The rest of an action's name should, typically, be in the singular form: `activateAccount`, `cancelSubscription`, `validateEmail`, `acceptInvitation`, `denyRequest`.

This naming convention helps to distinguish actions from resource-oriented endpoints, which are named using hyphen-delimited slugs.

==== Namespaces

Actions that operate on resources across multiple namespaces SHOULD be placed in the root namespace of the API. For example, an action that sends a notification to a user might be placed at `/v1/sendNotification`, rather than in either of the "users" or "notifications" namespaces.

.Template
----
POST|GET /v{major}/{action}
----

But it's better to scope actions to namespaces wherever possible. Actions and resources MAY coexist in the same namespaces. All actions within a namespace MUST only operate on the resources (including sub-resources) in the same namespace. If this design constraint cannot be achieved, better to elevate the actions to the API's global scope.

.Template
----
POST|GET /v{major}/{namespace}/{action}
----

A good practice is to create a collection of actions within each namespace. Collections of actions SHOULD be named, simply, "actions". This helps to distinguish actions from resources in each namespace.

.Template
----
POST /v{major}/{namespace}/actions/{action}
----

In addition, a `GET /v{major}/{namespace}/actions` endpoint MAY be provided to list all available actions in a namespace – similarly to how a list of available resources within a namespace can be retrieved.

==== Resource-scoped actions

There may be use cases for attaching actions to specific individual resources or collections, or even to sub-resources.

.Template
----
POST /v{major}/{namespace}/{resource}/{resource_id}/actions/{action}
----

Resource-scoped actions may make sense to separate operations that are fundamentally _business processes_ from operations that change the core state of the resources themselves.

A classic use case for resource-scoped actions is to avoid corrupting the entity model of a subdomain with transient data like comments. For example, for auditing purposes the business may require freeform comments to be attached to subscription cancellations. Since the comments would not be part of the model of a subscription resource, a resource-scoped action would be appropriate here. Users would post their comments to a `cancelSubscriptionComment` action, run subsequently to a `DELETE /subscriptions/{id}` request. This also works around a technical constraint with `DELETE` requests: you can't attach payloads to the message body of `DELETE` requests.

Actions SHOULD be terminal resources within an HTTP API, which means they SHOULD NOT have sub-resources (including sub-actions) relative to them.

==== Status codes

The following response codes are appropriate for successful action operations:

* `200` - The action was successfully executed, and the response body contains the result of the action, which may included updates to affected resources.

* `201` – The action successfully created one or more new resources. This will be appropriate for composite actions that create a root entity plus all its dependencies.

* `204` – Use this instead of `200` when there is no paylad in the response message. This will often be appropriate for actions that trigger out-of-band processes, such as sending notifications.

For errors, appropriate `4XX` or `5XX` error codes MAY be returned.

== Asynchronous operations

In general, synchronous operations SHOULD be preferred over asynchronous ones, as they simplify implementations on both the server-side and client-side. But there are some use cases where asynchronous operations are necessary or beneficial.

Asynchronicity is particularly advantageous in long-running tasks, such as image processing and video transcoding. It is also useful in operations that require interactions with external systems, such as sending emails or SMS messages, where the response time of the external system is unpredictable and where the client requires only confirmation that the message was _sent_ and does not require an immediate understanding of the outcome of that operation.

In implementing asynchronous operations, it is RECOMMENDED to conform to the following best practices.

Responses to resource creation, update, and deletion operations SHOULD return the `202 Accepted` status code. This indicates that the request has been accepted for processing, but the processing has not yet been completed.

The response body MAY include hypermedia links to any created or updated resources. There are two possible approaches to implementing this in the context of asynchronous operations. The first option is to include the final URL of the resource, from where clients can `GET` the latest representation of the resource in the normal way. This can be a good option in scenarios where the resource's ID and path are already known. If a newly-created resource is not yet ready, or if the resource has been deleted, the final URL SHOULD return the HTTP status code `404 Not Found`. Clients simply keep polling the provided endpoint until it is confirmed that the resource has been mutated as expected.

[source,json]
----
{
  "rel": "self",
  "method": "GET",
  "href": "/v1/namespace/resources/{resource_id}"
}
----

A second option is to return a temporary URL where the status of the queued operation may be obtained via some kind of temporary identifier.

[source,json]
----
{
  "rel": "self",
  "method": "GET",
  "href": "/v1/queue/requests/{request_id}"
}
----

It is RECOMMENDED that all HTTP APIs that implement asynchronous processing also support a single webhook that clients may optionally choose to implement to receive push notifications of any asynchronously-updated resources, or the results of any asynchronously-processed actions. This offers a third option for clients to keep their state synchronized with server changes – whether triggered by asynchronous operations or even by other clients. See the section on *Webhooks*, below, for further guidelines.

It may be desirable to support both synchronous and asynchronous processing on the same endpoints. One possible design pattern is to support synchronous processing by default but allow clients to opt-in to asynchronous processing using the `Prefer=respond-async` header.

== Concurrency control

A common issue in network API design is how to manage concurrent operations. There is always the potential for multiple clients to attempt to modify the same resource at the same time. This can lead to data corruption or lost updates.

These are not always issues, but where they are, APIs will need to implement concurrency control mechanisms. The appropriate mechanism will depend on the specific use case. But common patterns typically involve the use of ETags.

ETags (Entity Tags) are used to implement a strategy known as *optimistic concurrency control*. They are used to prevent accidental overwrites – the "lost update" problem, in which the most recent update always wins – by allowing clients to check if a resource has already been modified before requesting further mutations to that resource.

ETags themselves are unique identifiers assigned by a web server to a _specific version_ of a resource. When a resource changes, its ETag changes. ETags are returned in HTTP headers, allowing clients to detect changes to resources that originated from other clients.

When a client requests a resource, it receives an `ETag` header with a value that represents the current version of the resource represented in the message body. This may be any arbitrary value, but it is typically implemented as a hash of the resource's content.

----
ETag: "<etag_value>"
----

When the client subsequently requests an update to the resource, it includes in the request the ETag of the last version of the resource that it has. This is sent in the `If-Match` header.

The server then checks if the ETag in the request matches the current version of the resource known to the server. If they match, the update proceeds. If they do not match, it means another client has updated the resource in the meantime, and the update fails with a `412 Precondition Failed` status code.

== Headers

=== Non-standard headers

Non-standard headers SHOULD be prefixed with `X-` to indicate that they are custom headers, and to avoid potential conflicts with future standard headers.

Examples:

* `X-Request-Id`: A unique identifier for the request, used for logging and tracing, and to implement idempotent operations.

* `X-Correlation-Id`: A unique identifier to correlate requests and responses through distributed systems. This may be useful in scenarios where a client does not supply an `X-Request-Id` header, or where processes are initialized by the system (such as batch processes or scheduled jobs) rather than by a user.

* `X-Client-Id`: A unique identifier for the client application making the request. This may be useful where you want to track the behavior of a specific client application, rather than a specific user.

=== `Prefer` header

HTTP APIs MAY support the `Prefer` header. This standard HTTP header is specified in https://tools.ietf.org/html/rfc7240[RFC 7240]. It is used by clients to opt-in to specific behaviors when the server is processing the client's requests.

The `Prefer` header is useful for a number of use cases. Perhaps the most common use case is to allow clients to opt-in to receiving a response body, encoding up-to-date resources, for requests that would not otherwise receive one. For example, instead of `PUT` and `PATCH` requests receiving a `204 No Content` response by default, clients can opt-in to receiving a `200 OK` response with the updated resource in the response body. This can be useful for clients that need to capture system-generated fields, such as `create_time` and `update_time`, or where clients benefit from receiving up-to-date representations of resources that are particularly volatile.

By default, HTTP APIs should return full representations of requested and updated resources. But sometimes the client does not need the full representation and the client-server interaction can therefore be optimized by returning partial representations of resources. This can be particularly beneficial in collections in which individual resources are large objects in their complete representations. Clients may therefore choose to fetch minimal or summarized lists of resources, and then fetch the full representations of individual resources as-and-when needed.

The `Prefer: return=minimal` header MAY be used for this purpose. The definition of a "minimal" representation is left to the discretion of the service, but it SHOULD be documented as part of the API's interface specification.

****
To gives clients even more granular control over the subset of resource data that they receive, API services MAY instead support a query parameter named `fields`. This accepts a comma-separated list of field names that the client is interested in. The response body SHOULD include only the fields that are listed in the `fields` query parameter, plus any required fields that the server always provides.

----
GET https://api.example.com/v1/users/bob?fields=department,title,location
----

The `fields` pattern, if implemented, SHOULD be supported globally across all resources and collections.

The `fields` query parameter SHOULD NOT be used in conjunction with the `Prefer: return=minimal` header. Clients SHOULD be expected to supply one or the other, or neither, but not both.
****

=== Response caching

HTTP API servers MUST provide guidance to clients on appropriate caching of response messages. Clients MAY cache responses based on the guidance issued by the server.

Client-side caching is typically guided using the `Cache-Control` header.

// TODO: More details of possible implementation strategies.

== Payloads

The content, or payload, of HTTP request and response messages SHOULD be in the JSON format, for the majority of regular use cases. JSON is natively supported by most modern programming languages, it is human-readable as well as machine parsable, and has become the _de facto_ standard for encoding data in HTTP APIs.

It is RECOMMENDED to _always_ return some kind of message to the client, except for `204 No Content` statuses. Even if the message is just `success: true`, and doesn't add any more semantic meaning than is conveyed through the status code, it can still be useful for the purpose of testing (eg. using tools like Postman). A little bit of redundancy between payload content, headers, and status codes is okay.

== Versioning and managing breaking changes

HTTP APIs SHOULD have a major version number that is incremented whenever there are breaking changes in the API. The major version number SHOULD be encoded in the first path segment of the URL.

.Template
----
/v{major}
----

.Example
----
/v1
----

Use the *expanding contract* pattern to maintain backwards compatibility with clients, while incrementally evolving the API's design and capabilities. This is also known as the *additive* approach to building programmatic interfaces.

In practice, this means:

* Breaking changes MUST NOT be made to APIs that are already in use.

* Developers MUST NOT add new required parameters to existing APIs.

* Developers MUST NOT remove existing required parameters.

* Developers MUST NOT change the meaning of existing parameters.

* APIs MUST be designed to be extensible.

A good example of a scalable API design is one that avoids array of scalar data types (strings, integers, etc.). Consider the following example:

[source,json]
----
"countries": [
  "Brazil",
  "France"
]
----

This data structure is impossible to extend without introducing breaking changes. Always prefer arrays of objects, eg.:

[source,json]
----
"countries": [
  { name: "Brazil" },
  { name: "France" }
]
----

Breaking changes include any changes to the request or response message formats, changes to the semantics of the API, or changes to the behavior of the API.

Where breaking changes are unavoidable, the breaking changes MUST be implemented in a new major version of the API. The old version of the API MUST be maintained for a reasonable period of time to allow clients to migrate to the new version.

APIs MUST have a documented *lifecycle policy*, which describes the support and maintenance of each major version of the API.

== Webhooks

Webhooks are API endpoints that are typically used to receive notifications about events that happen in third-party systems, such as when a payment has been successfully processed, when a subscription is cancelled, or when a service fails to send an SMS message.

Webhooks take two forms, each of which requires different design considerations:

* *Inbound webhooks*: These are _private_ endpoints that your service exposes to receive notifications from one or more third-party services.

* *Outbound webhooks*: These are messages sent out from a service to the webhook endpoints of other services.

Inbound webhooks are not really part of an HTTP API's public interface, but rather they are special-purpose private endpoints that sit alongside the main public endpoints of an HTTP API. Their purpose is to facilitate integration with other services (usually services operated by third-parties). They are not used directly by the service's own users/customers. Inbound webhooks may be exposed via different URLs schemas and HTTP methods than the main API endpoints, and things like payload schema and authentication mechanisms will be determined by the third-party services.

Outbound webhooks, on the other hand, are a form of event notification, and they are very much part of the application programming interface (API) of the service from which they are emitted. And yet they may sit apart from the main HTTP API endpoints of that service. Outbound webhooks may use different transport protocols, different message formats, different schemas, different methods of authentication, and they may even be versioned independently of the service's main API.

****
See also link:./017-messages.adoc[TS-17: Messages and Events], which covers concerns related to event schema and asynchronous event handling – topics that are relevant to the implementation of webhooks.
****

=== Webhook URL schemes

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/webhooks/{party}/{namespace}/v{version}/{event_type}/{…}
----

Where:

* `{party}` is the name of the third-party service that is authorized to use the endpoint.

* `{namespace}` is an optional path component used to scope a webhook to a particular service of the third-party.

* `{version}` identifies the version number of the third-party's webhook API or event schema that is supported by the endpoint.

* `{event_type}` is a component that identifies a particular type of event that the endpoint is designed to subscribe to. (This can simply be the word "event" if all that is needed is a single endpoint to process all kinds of events emitted by a third-party service.)

* `{…}` refers to any additional URL path components that are required by the client in the webhook implementation, for example for the purpose of passing resource identifiers.

Consider the following examples of webhook URLs, which use the above scheme:

* `/webhooks/authentiq/v3/event`
* `/webhooks/true-id/v1/event`
* `/webhooks/transactify/v1/transaction-initiated`
* `/webhooks/transactify/v1/transaction-complete`
* `/webhooks/transactify/v2/transaction-initiated`
* `/webhooks/transactify/v2/transaction-complete`

This fictional API exposes six webhook endpoints, which are used to receive notifications from three different third-party services:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this service. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* A similar webhook is for a service called TrueID. The endpoint supports version 1 of TrueID's webhook event schema. We're pretending that TrueID is a legacy identity verification service that is being phased out, and eventually replaced by AuthentiQ. In this transition phase, the system needs to support both services in parallel.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

These examples demonstrate the following features of this webhook URL scheme.

First, multiple third-party services can be supported simultaneously. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. In addition, this design makes it possible to incrementally transition from one service provider to another (eg. swapping the payment service gateway) without breaking your own service.

Second, the `{version}` component is independent of the HTTP API's own versioning scheme, and indeed this may vary between individual webhooks. In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhooks are an exception. These are scoped instead to the versions of the _clients_ that interact with the webhook endpoints. After all, it is the client that specifies the interface contract for its webhooks: the HTTP methods, payload structures, authentication and authorization mechanisms, and so on. Usually, the only thing under the control of the server is the URL scheme.

Thus, webhooks MUST be versioned independently to an API's main endpoints, and also to each other. Individual webhooks can thus be incremented independently. It becomes possible to handle two or more incompatible versions of a webhook's event schema in parallel. If a client makes breaking changes to their event schema, you will be able to transition to the new schema in an incremental, non-breaking way. You can do this by publishing a new handler for the new event schema alongside the existing handler for the existing schema, eg.

* `/webhooks/{party}/v3/receive-event`
* `/webhooks/{party}/v4/receive-event`

[TIP]
======
If a client does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the client's own web service API. If this is not possible either, you can invent your own versioning system for the client. The goal is to be able to handle multiple versions of a webhook in parallel.
======

Finally, multiple webhooks can be be supported for a single third-party service. It is often the case that client's require a single webhook via which they can notify subscribers of _all_ events. But sometimes it can be beneficial, or even necessary, to process different types of events (from the same client) in different ways. For example, you may want to process "transaction-initiated" events differently from "transaction-complete" events.

=== Outbound webhook event schema

When designing outbound webhooks, the main consideration is the schema of the events that will be sent to the webhook endpoints of third-party services. The event schema defines the structure and format of the data that will be sent in the webhook payloads. A well-defined event schema is crucial for ensuring that webhook consumers can correctly interpret and process the events they receive.

link:./017-messages.adoc[TS-17: Messages and Events] provides guidance on designing event schemas, including recommended metadata fields and payload structures.

=== Webhook status codes

When integrating with third-party services via inbound webhooks, those third-party services MAY require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the third-party service specifies the status codes that it expects, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular status codes.

If a third-party service does not specify the status codes that it expects, then it is RECOMMENDED to return a `202 Accepted` for all success scenarios. This status code indicates that the request has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook requests, as it allows the server to process the request asynchronously – the webhook message gets added to a queue and processed later – which is a best practice.

To indicate errors, the RECOMMENDED return codes are:

* `400 Bad Request` for client errors, which you should return when a message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization (permissions, scopes) checks.
* `404 Not Found` when the requested resource does not exist.
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5xx` code, you are basically saying to the client "please retry this later".

When designing your own outbound webhook messages, you will need to consider the status codes that you will want third-party services to return in response to your webhook messages. It is RECOMMENDED:

* To accept any `2xx` status code to indicate successful processing of a webhook message (ie. any `2xx` code will be treated by you as `202 Accepted`).
* To log any `4xx` status codes for further investigation,
* To treat `5xx` status codes as server errors, which will feed into your retry and dead-letter queue mechanisms.
* To treat any `4xx` client errors in the same way as `5xx` server errors, but in addition log them for further investigation.
* To treat `1xx` and `3xx` status codes as generic `500` server errors.

== Versioning

HTTP APIs SHOULD have a major version number that is incremented whenever there are breaking changes in the API. The major version number SHOULD be encoded in the first path segment of the URL.

.Template
----
/v{major}
----

.Example
----
/v1
----

Use the *expanding contract* pattern to maintain backwards compatibility with clients, while incrementally evolving the API's design and capabilities. This is also known as the *additive* approach to building programmatic interfaces.

In practice, this means:

* Breaking changes MUST NOT be made to APIs that are already in use.

* Developers MUST NOT add new required parameters to existing APIs.

* Developers MUST NOT remove existing required parameters.

* Developers MUST NOT change the meaning of existing parameters.

* APIs MUST be designed to be extensible.

A good example of a scalable API design is one that avoids array of scalar data types (strings, integers, etc.). Consider the following example:

[source,json]
----
"countries": [
  "Brazil",
  "France"
]
----

This data structure is impossible to extend without introducing breaking changes. Always prefer arrays of objects, eg.:

[source,json]
----
"countries": [
  { name: "Brazil" },
  { name: "France" }
]
----



Where breaking changes are unavoidable, the breaking changes MUST be implemented in a new major version of the API. The old version of the API MUST be maintained for a reasonable period of time to allow clients to migrate to the new version.

APIs MUST have a documented *lifecycle policy*, which describes the support and maintenance of each major version of the API.


= TS-16: HTTP APIs
:toc: macro
:toc-title: Contents

This document outlines standards for designing and implementing HTTP APIs. It also covers best practices for the implementation of webhooks (both inbound and outbound).

These standards are applicable to both private HTTP APIs between services within distributed software systems ("inter-service communication") and to public HTTP APIs that are made available for integration into third-party client applications ("web services").

In this technical standard, URLs containing variables are specified according to https://tools.ietf.org/html/rfc6570[IETF RFC 6570: URI Template]. For example, a URL containing a variable called `account_id` would be shown as `https://api.example.com/v1/accounts/{account_id}`.

toc::[]

== General design principles

HTTP APIs, both public and private ones, SHOULD be formed from a consistent set of design patterns – a pattern library. This facilitates a better developer experience and supports greater reuse of code, for example through libraries and software development kits (SDKs), so making integrations quicker and easier.

In broad terms, HTTP APIs SHOULD follow the https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm[RESTful architectural style]. This architecture describes the underlying design principles of the World Wide Web, but particularly of the HTTP protocol and HTML language. In practice, a RESTful API is one that repurposes the semantics of the HTTP protocol, using the full capabilities of HTTP as a messaging and encoding protocol, rather than merely as a transport protocol. In simple terms, a RESTful API uses URLs to represent resources and collections of resources, HTTP methods to represent different types of CRUD-like operations to be performed on those resources, and HTTP status codes to represent outcomes from those operations.

A RESTful API is also:

* *Stateless*: Each request from a client to a server SHOULD contain all the information necessary for the server to understand and fulfil the request. Most client requests SHOULD NOT be dependent upon any particular stored context on the server – with exceptions for things like security measures to protect against denial of service. This design constraint will simplify the server implementation and make it more scalable.

* *Uniform*: A RESTFUL API SHOULD have a highly uniform interface, which means it uses a consistent subset of HTTP methods and status codes, composes message content from a common library of types, and uses a consistent URL structure to represent resources and collections. This constraint will help to simplify client implementations, promote code reuse, and make integrations easier.

* *Cacheable*: As much as possible, responses from a RESTFUL API server SHOULD be cacheable. This helps to reduce load on the server, reduce latency for clients, and supports strategies for fault tolerance and availability.

* *A layered system*: The server application SHOULD have a layered architecture, in which cross-cutting concerns such as security and caching are implemented in discrete layers that span all endpoints of the API.

The following RESTful design constraints are OPTIONAL:

* *Hypermedia as the engine of application state (HATEOAS)*: HTTP APIs MAY embed hypermedia links through which clients can explore the available resources and operations of the API. Clients MAY use the encoded hypermedia controls to read, query, and update application state. This design constraint is not commonly used in practice, but it can be beneficial for some use cases. HATEOAS may be appropriate for APIs that are intended to be consumed directly by human users, who interact with the API through a generic program to explore the available resources and operations, which themselves are constantly evolving. HATEOAS is less useful for APIs that are intended for programmatic integration into other computer systems.

* *Code on demand*: The server MAY send executable code to the client, to extend the functionality of the client. Again, this design constraint is not commonly used in practice, but one possible use case would be for an API to serve updates to SDKs, written in various programming languages, that are dynamically integrated into client applications.

Although most HTTP APIs should be primarily RESTful, or resource-oriented, there are many use cases where a RESTful design is not appropriate. For example, if an API is a thin layer around a legacy system that itself is not designed around resources or fits uncomfortably with the RESTful model, it may be necessary to deviate from RESTful design principles and focus on creating a functional abstraction of the underlying system.

Even within an HTTP API that is predominantly RESTful in its design characteristics, it will often be beneficial to include operations that are more RPC-like in their design. For example, besides the usual create, read, update, and delete operations that are made available on a collection of resources, an HTTP API may augment these operations with additional "actions" that perform tasks on the resources that do not neatly fit the CRUD model, or which abstract multiple CRUD-like operations in a single request. See the section on *Actions* for more information.

In designing an HTTP API, developers SHOULD prioritize creating an accurate model of the system that the API abstracts, rather than trying to religiously adhere to any particular architectural style. Remember, the goal of an HTTP API is to provide a useful and usable interface to a complex system. The best API design will be the one that makes it as easy as possible for clients to interact with the underlying system.

== Authentication and authorization

Authentication and authorization MUST be implemented for all HTTP APIs, including private (internal network) HTTP APIs.

Authentication and authorization is especially important for operations that modify data.

== Security

Security measures MUST be implemented for both public and private APIs. Do not assume that private/internal networks are secure.

All input MUST be validated and sanitized to prevent security vulnerabilities such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF).

== HTTP methods

HTTP methods define actions to be performed on a resource or collection of resources.

HTTP methods MUST be used for their designated purpose, as specified by the HTTP standards. This will make it much easier for client applications to be integrated with the API.

HTTP APIs MUST use only the following subset of standard HTTP methods:

|===
|Verb |CRUD usage |Description

|GET
|Read
|Used to retrieve the requested resource. GET operations MUST NOT modify the state of the resource, and there MUST NOT be any other side effects.

|HEAD
|Read
|Used to retrieve only the headers of a resource – it returns the same as GET but without the body.

|POST
|Create
|Used to create a new resource. The server MUST generate a new resource identifier and return it in the response.

|PUT
|Create/Update
|Used to fully replace a resource with the request payload, or to create a new resource in scenarios where the client takes over responsibility from the server for generating a unique identifier for the resource.

|PATCH
|Update
|Used for partial updates to a resource. The request payload SHOULD contain only the fields that are being updated.

|DELETE
|Delete
|Used to delete a resource. Should be repeatable, always with a positive response even if the resource is already deleted.
|===

Other standard HTTP methods are `OPTIONS`, `TRACE`, and `CONNECT`. These are technical methods used to support the HTTP protocol itself, and are not intended the be included in the interface definitions for HTTP APIs.

== HTTP status codes

Appropriate HTTP response codes MUST be used in response messages to indicate the result of API requests. Using the correct codes in responses is not just about adhering to the HTTP protocol, but also about facilitating the correct interpretation of HTTP responses by clients.

There are many standardized HTTP status codes. Most APIs will need only a subset of the full set of standard codes. The supported subset of HTTP status codes MUST be documented as part of the API's interface definition. Commonly-used status codes include:

* *1xx*: Informational response codes.

  ** `100 Continue`: Indicates that the initial part of the request has been received and the client should continue sending the rest of the request.

* *2xx*: Success response codes.

  ** `200 OK`: Indicates that the request was successful. This is the most widely-used success response code.

  ** `201 Created`: Indicates that the request was successful and, as a result, a new resource has been created.

  ** `202 Accepted`: For asynchronous operations that will be fulfilled by the server at a later time.

  ** `204 No Content`: Indicates that the request was successful but there is no content to return in the response message. This status code MUST be returned with an empty HTTP message body.

* *3xx*: Redirection response codes.

  ** `301 Moved Permanently`: Indicates that the requested URL has been changed permanently. The new URL MUST be specified in the response.

  ** `302 Found`: Indicates that the requested resource is temporarily under a different URL.

* *4xx*: Client error response codes.

  ** `400 Bad Request`: Indicates that the request cannot be understood or processed by the server due to a syntax error in the client's request message.

  ** `401 Unauthorized`: Indicates that the request requires authentication but the client has not authenticated itself.

  ** `403 Forbidden`: Indicates that the server understood the request but is refusing to authorize access to the specific resource requested.

  ** `404 Not Found`: Indicates that the server could not find the requested resource.

  ** `405 Method Not Allowed`: Indicates that the HTTP method used in the request is not allowed on the target resource (but the resource exists and other methods can be run on it).

* *5xx*: Server error response codes.

  ** `500 Internal Server Error`: Indicates that the server encountered a situation it doesn't know how to handle.

  ** `502 Bad Gateway`: Indicates that the server, while acting as a gateway or proxy, received an invalid response from an upstream server.

  ** `503 Service Unavailable`: Indicates that the server is not ready to handle the request, typically due to maintenance or overload.

== URLs

URLs identify resources, collections of resources, and actions.

=== Path delimiters

The forward slash (`/`) character is used to delimit between path segments in URLs.

API documentation SHOULD be consistent in its use of trailing slashes. It is RECOMMENDED that trailing slashes be omitted in documentation. However, an API SHOULD accept requests with or without a trailing slash, but SHOULD NOT respond with a redirect to the canonical version.

.Postel's Law (aka. the Robustness Principle)
****
Be liberal in what you accept, and conservative in what you send.
****

=== Versioning

HTTP APIs MUST be versioned, and version information SHOULD be encoded in the URL path. This pattern is widely used for its simplicity of use by clients and compatibility with caching and proxying systems (compared to alternative designs such as header-based versioning).

HTTP APIs MUST use https://semver.org/[Semantic Versioning], as specified in *link:./005-versioning.adoc[TS-5: Versioning]*. However, only the major version number needs to be exposed in the URL schema.

It is RECOMMENDED that the major version number be the first segment of the URL path, eg. `/v1`. This tends to make it easier for clients to implement version-specific behavior, and it also tends to make it easier to maintain and deploy multiple major versions of an API in parallel on the server side.

.Template
----
/v{major}
----

.Example
----
/v1
----

See the *Versioning* section, below, for more guidance on HTTP API versioning.

=== Namespaces

The next part of the URL path SHOULD be treated as a "namespace" in which related resources will be grouped.

Namespaces are used to create logical groups of resources, collections, and actions. But they do not necessarily map directly to modules or back-end services that are responsible for fulfilling requests. Namespaces SHOULD reflect the customer's perspective of how the product works. That perspective may not necessarily reflect the internal structure of the system, or the business domains and subdomains.

.Template
----
/v{major}/{namespace}
----

.Example
----
/v1/vault
----

Namespaces SHOULD be nouns but MAY be either singular or plural, as appropriate for each grouping of resources, collections, and actions.

=== Resources and collections

The remaining segments of a URL path are used to identify resources and collections of resources,

Consistent path components SHOULD be used to refer to the same resources, and collections of them, across different endpoints.

.Templates
----
GET /v{major}/{namespace}/{resource}
GET /v{major}/{namespace}/{resource}/{resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}
----

Sub-resources and sub-collections MAY be supported, too.

.Templates
----
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
----

The `{resource}` and `{sub_resource}` components SHOULD be named using nouns. These SHOULD be in the singular form where there is only ever one instance of the resource, and never a collection of resources of the same type. More commonly, there will be collections of each type of resource and sub-resource, and these SHOULD be named in the plural form.

Resource-oriented endpoints SHOULD use lowercase hyphen-delimited slugs to name resources and sub-resources. Examples: "account", "users", "billing", "charge-points", "charge-points/{charge_point_id}/sessions", "credit-cards", "credit-cards/{credit_card_id}/transactions".

== Collections

A collection is a list of multiple resources of the same type, plus any related metadata.

Collections, and the resources they encapsulate, SHOULD be named consistently across different endpoints. This allows clients to implement generic data access handling.

.Template
----
GET /v{major}/{namespace}/{resource}
----

.Example
----
GET /v1/vault/credit-cards
----

// TODO: Update to match standard schema.
.Example response
----
{
  "metadata": {
    "total_items": 1,
    "total_pages": 1
  },
  "items": [
    {
      "data": {
        "id": "123e4567-e89b-12d3-a456-426614174000",
        "type": "visa",
        "number": "xxxxxxxxxxxx0331",
        "expires": {
          "month": "11",
          "year": "2018",
        },
        "name": {
          "first": "Joe",
          "last": "Shopper"
        }
      },
      "metadata": {
        "create_time": "2014-01-13T07:23:15Z",
        "update_time": "2014-01-13T07:23:15Z",
      },
      "links": [
        {
          "rel": "self",
          "method": "GET"
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        },
        {
          "rel": "delete",
          "method": "DELETE",
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        },
        {
          "rel": "patch",
          "method": "PATCH",
          "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000"
        }
      ]
    }
  ],
  "links": [
    {
      "rel": "self",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards?page=3&per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "prev",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=2&per_page=10&sort_by=create_time&sort_order=asc
    },
    {
      "rel": "next",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=4&per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "first",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?per_page=10&sort_by=create_time&sort_order=asc"
    },
    {
      "rel": "last",
      "method": "GET",
      "href": "https://api.example.com/v1/vault/credit-cards/?page=123&per_page=10&sort_by=create_time&sort_order=asc"
    }
  ]
}
----

=== Pagination

Any collection that could contain a large, potentially unbounded list of resources SHOULD implement pagination. The following design patterns are RECOMMENDED.

----
/accounts?per_page={per_page}&page={page}
----

Pages of results SHOULD be referred to consistently by the query parameters `page` and `per_page`, where `per_page` is a non-zero positive integer representing the number of results per paginated response, and `page` is a number of 1 or more that represents the current page of results requested.

The `per_page` query parameter SHOULD be optional. If not provided by the client, the server should fallback to a sensible, specified default.

The `page` query parameter SHOULD also be optional. If not provided by the client, the server MUST return the first page of results (ie. the default value for `page` MUST be 1).

The values of both `page` and `per_page` MUST be validated by the server. A `400 Bad Request` SHOULD be returned for semantically invalid values. However, if the requested range if outside of the available range of results (eg. `per_page=100&page=2` is requested but there are only 50 results) a `200 OK` response SHOULD be returned with an empty result list, not a `404 Not Found`.

In certain cases, such as querying on a large data set, in order to optimize the query execution with pagination, it may be appropriate to retrieve the data based on the result set of the previous page. A `page_token` parameter MAY be used for this purpose. This could be, for example, an encrypted value of primary keys to navigate to the next and previous pages, along with directions.

Additionally, responses MAY include `total_items` and `total_pages` metadata fields. `total_items` indicates the total number of items in the collection, and `total_pages` is the number of pages (interpolated from `total_items`/`per_page`). This will help clients to implement better user experiences, for example by disabling navigation to pages that are outside of the available range. Where providing the `total_items` and `total_pages` requires expensive queries on the server-side, the client SHOULD be able to opt-in to receiving this information using a query parameter, for example `?include_totals=true`.

Hypermedia links with `rel` attributes for "next", "previous", "first", and "last" pages SHOULD be included in paginated collections, to make it easier for clients to navigate through collections. The `page` and `per_page` query parameters, inputted by the client, MUST be maintained for each link, to ensure consistent client behavior. See the section on *Hypermedia* for more information.

=== Filtering

Collections MAY be filtered by default. For example, resources to which a user is not authorized to access MUST NOT be included in a collection. If all resources in a collection are not authorized, returning a `403 Forbidden` response would be appropriate.

Additional, optional filtering may be applied by clients using query parameters. For example, the following query parameters MAY be available for clients to filter collections by a time range:

* `start_time` or `{property_name}_after`: An ISO-8601 date and time string that represents the start of a temporaal range. `start_time` may be used when there is only one unambiguous time dimension, otherwise the property name should be used, eg, `processed_after`, `uploaded_after`. The property SHOULD map to a time field in the representation.

* `end_time` or `{property_name}_before`: An ISO-8601 date and time string indicating the end of a temporal range. `end_time` may be used when there is only one unambiguous time dimension, otherwise the property name should be used, eg. `processed_before`, `uploaded_before`. The property SHOULD map to a time field in the representation.

These query parameters SHOULD be used consistently across all endpoints that support time-based filtering.

=== Searching

Search query parameters MAY be supported on collections, to allow clients to filter collection lists based on freeform input. The query parameter SHOULD be named `q` and MAY be used to search across multiple fields of the resources.

=== Sorting

Results could be ordered according to sorting-related instructions given by the client. This includes sorting by a specific field's value, and sorting order.

The following URL parameters SHOULD be used for this purpose:

* `sort_by`: A dimension by which items should be sorted. The dimensions SHOULD be an attribute in the item's representation.

* `sort_order`: The order, one of "asc" or "desc", indicating ascending or descending order.

The default sort field and sort order MUST be documented for each collection. All collections have a default sorting, except in use cases where the order is deliberately randomized (if so, this still needs to be specified).

=== HTTP statuses

If a collection is empty (ie. it has zero items), returning `404 Not Found` is not appropriate. It was the collection that was requested, not a specific item in the collection. And the collection exists – it is just empty. Instead, return a `200 OK` response with an empty `items` array.

Invalid query parameters SHOULD be signalled with a `404 Bad Request` response.

== Resources

=== Reading

Single resources are typically discovered through a collection, and are identified by a unique identifier. When reading single resources, a more detailed representation of the resource MAY be returned than the default, minimized representations included in collections.

A resource's unique identifier SHOULD be unique to all resources of all types, not only resources of the same type or in the same collection. UUIDs are RECOMMENDED for this purpose, as each generated UUID is more-or-less guaranteed to be unique globally.

Identifiers for sensitive data SHOULD be non-sequential, and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers SHOULD be used for readability and debugging.

If the provided resource identifier is not found, even if the data is "soft deleted" in the data source, the response status code should be `404 Not Found`. Otherwise, `200 OK` MUST be returned when the resource is found.

.Template
----
GET /v{major}/{namespace}/{resource}/{resource_id}
----

.Example
----
GET /v1/vault/customers/123e4567-e89b-12d3-a456-426614174000
----

=== Updating

There are two ways to update resources:

* Using `PUT` to fully replace the resource.
* Using `PATCH` to partially update the resource.

In both cases, the shape of the input data SHOULD be consistent with the shape of the resource representation returned by the API via the corresponding GET requests. The only difference is that `PATCH` may submit fewer fields – essentially a diff of what's changed since the last `GET`.

For `PUT` requests, system-calculated values such as `create_time` and `update_time` SHOULD be optional and SHOULD be ignored on deserialization by the server. For `PATCH` requests, clients SHOULD be expected to omit these fields from the request body, and the server SHOULD return `400 Bad Request` if they are included. For `PATCH` requests, the client is expected to submit only the fields that have been updated by the client, and since the client cannot update system-calculated values, trying to do so should be treated as a client error.

.Template
----
PUT|PATCH /v{major}/{namespace}/{resource}/{resource_id}
----

Alternatively, standards such as https://datatracker.ietf.org/doc/html/rfc6902[JSON Patch] MAY be implemented for https://tools.ietf.org/html/rfc5789[PATCH] requests. Rather than sending a partial representation of the resource, clients instead send a list of operations to be made on particular members or fields of the resource.

[source,http]
----
PATCH /widgets/abc123 HTTP/1.1
Host: api.example.com
Content-Length: ...
Content-Type: application/json-patch

[
  {
    "op": "replace",
    "path": "/a/b/c",
    "value": 42
  },
  {
    "op": "remove",
    "path": "/a/b/c"
  },
  {
    "op": "move",
    "from": "/a/b/c",
    "path": "/a/b/d"
  }
]
----

The value of the "path" field is a https://tools.ietf.org/html/rfc6901[JSON Pointer] that references the location within the target document where the operation is to be performed. For example, the path `/a/b/c` refers to the element "c" in the below JSON:

[source,json]
----
{
  "a": {
    "b": {
      "c": "",
      "d": ""
    },
    "e": ""
  }
}
----

The supported operations are "add", "remove", "replace", "move", "copy", and "test". To support partial updates to fixed-schema resources, APIs need to support only "add", "remove", and "replace" operations.

After a successful update operation, both `PUT` and `PATCH` operations SHOULD normally respond with `204 No Content` status, with no accompanying response body. However, there may be use cases where it is preferable to instead return `200 OK` with an updated resource in the response body. For example, this may be required where clients need updates to system-calculated fields, or otherwise to optimize client-server interactions. Alternatively, clients may opt-in to receiving a `200 OK` response with a response body by including the request header `Prefer:return=representation`.

Any update request (whether PUT or PATCH) that fails input validation MUST receive a `400 Bad Request` response. If clients attempt to modify read-only fields, or if the resource is in a non-updatable state, this is also a `400 Bad Request`. If there are business rules or validation constraints, eg. for data type, length, etc., that are not satisfied, a `400 Bad Request` response is appropriate. In addition, appropriate error codes and messages SHOULD be encoded in the response body.

For situations that require interaction with downstream servers or external APIs or processes, returning the `422 Unprocessable Entity` status code may be more appropriate than `400 Bad Request`.

=== Deleting

In order to enable retries (eg. due to patchy connectivity), and for conformance with HTTP standards, `DELETE` operations MUST be implemented to be idempotent. This means that successful `DELETE` operations MUST always respond with `204 No Content`, even if the resource is already deleted. Returning `404 Not Found` is not appropriate for `DELETE` operations in this scenario, as it suggests that the resource never existed at all. If necessary, clients can use `GET` to verify the resource exists prior to `DELETE`.

.Template
----
DELETE /v{major}/{namespace}/{resource}/{resource_id}
----

There may be use cases where a client expects resources to exist but they unexpectedly disappear. This could be because a resource expired, or because of some policy, such as a data retention operation that cleans-up stale data. In these use cases, services MAY return a `410 Gone` error code in response to a request for a resource that no longer exists. Doing so provides the client with extra information (it tells the client that the resource had already been deleted).

For historical reasons, many web servers and HTTP client libraries do not expect a message body to be included in HTTP messages sent using the `DELETE` method. To support the widest possible range of clients, it remains good practice to _not_ require DELETE requests to be accompanied by a payload. This is an OPTIONAL constraint, and is only REQUIRED if there are known to be clients that will be unable to support DELETE requests with payloads.

=== Creating

There are two ways to create resources:

* Using `POST` to create a resource but have the server create an identifier for it.
* Using `PUT` to create a full resource, including a unique identifier that is generated client-side.

.Template
----
POST|PUT /v{major}/{namespace}/{resource}/{resource_id}
----

`PUT` operations are idempotent by default, because the request payload has a built-in unique identifier in the form of the resource ID, generated by the client.

`POST` operations are NOT idempotent by default, and therefore there is risk that duplicates of the same resource may be created if the client retries a `POST` request. Where it is necessary to prevent this, clients MUST include a unique identifier for the _request_ message (eg. `request_id`). The server will use the request ID to make sure it processes only the first instance that it receives of each distinct request.

For `PUT` requests, system-calculated values such as `create_time` and `update_time` SHOULD be made optional and SHOULD be ignored on deserialization by the server. But for `POST` requests, clients SHOULD be expected to omit these fields from the request body, and therefore the server SHOULD return `400 Bad Request` when such fields are included in the request content.

Otherwise, both operations SHOULD behave in the same way. Both `POST` and `PUT` payloads MAY include only a subset of input fields (only the required fields, for example), with the server filling in optional fields with default values.

The number of required fields SHOULD be minimized as much as reasonably possible for the business case.

For both `POST` and `PUT` creation operations, successful outcomes MUST be signalled by a `201 Created` response, and a representation of the created resource MUST be returned in the response body – including any server-generated fields such as `create_time`.

Response messages SHOULD include a list of hypermedia links that represent all the available operations that can be performed on the newly-created resource. For example, if only `GET` and `DELETE` operations are available:

.Example response
----
{
  "data": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "type": "visa",
    "number": "xxxxxxxxxxxx0331",
    "expire_month": "11",
    "expire_year": "2018",
    "first_name": "Joe",
    "last_name": "Shopper",
  },
  "links": [
    {
      "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000",
      "rel": "self",
      "method": "GET"
    },
    {
      "href": "https://api.example.com/v1/vault/credit-cards/123e4567-e89b-12d3-a456-426614174000",
      "rel": "delete",
      "method": "DELETE"
    }
  ]
}
----

== Webhooks

Webhooks are API endpoints that are typically used to receive notifications about events that happen in third-party systems, such as when a payment has been successfully processed, when a subscription is cancelled, or when a service fails to send an SMS message.

Webhooks take two forms, each of which requires different design considerations:

* *Inbound webhooks*: These are _private_ endpoints that your service exposes to receive notifications from one or more third-party services.

* *Outbound webhooks*: These are messages sent out from a service to the webhook endpoints of other services.

Inbound webhooks are not really part of an HTTP API's public interface, but rather they are special-purpose private endpoints that sit alongside the main public endpoints of an HTTP API. Their purpose is to facilitate integration with other services (usually services operated by third-parties). They are not used directly by the service's own users/customers. Inbound webhooks may be exposed via different URLs schemas and HTTP methods than the main API endpoints, and things like payload schema and authentication mechanisms will be determined by the third-party services.

Outbound webhooks, on the other hand, are a form of event notification, and they are very much part of the application programming interface (API) of the service from which they are emitted. And yet they may sit apart from the main HTTP API endpoints of that service. Outbound webhooks may use different transport protocols, different message formats, different schemas, different methods of authentication, and they may even be versioned independently of the service's main API.

****
See also link:./017-messages.adoc[TS-17: Messages and Events], which covers concerns related to event schema and asynchronous event handling – topics that are relevant to the implementation of webhooks.
****

=== Webhook URL schemes

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/webhooks/{party}/{namespace}/v{version}/{event_type}/{…}
----

Where:

* `{party}` is the name of the third-party service that is authorized to use the endpoint.

* `{namespace}` is an optional path component used to scope a webhook to a particular service of the third-party.

* `{version}` identifies the version number of the third-party's webhook API or event schema that is supported by the endpoint.

* `{event_type}` is a component that identifies a particular type of event that the endpoint is designed to subscribe to. (This can simply be the word "event" if all that is needed is a single endpoint to process all kinds of events emitted by a third-party service.)

* `{…}` refers to any additional URL path components that are required by the client in the webhook implementation, for example for the purpose of passing resource identifiers.

Consider the following examples of webhook URLs, which use the above scheme:

* `/webhooks/authentiq/v3/event`
* `/webhooks/true-id/v1/event`
* `/webhooks/transactify/v1/transaction-initiated`
* `/webhooks/transactify/v1/transaction-complete`
* `/webhooks/transactify/v2/transaction-initiated`
* `/webhooks/transactify/v2/transaction-complete`

This fictional API exposes six webhook endpoints, which are used to receive notifications from three different third-party services:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this service. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* A similar webhook is for a service called TrueID. The endpoint supports version 1 of TrueID's webhook event schema. We're pretending that TrueID is a legacy identity verification service that is being phased out, and eventually replaced by AuthentiQ. In this transition phase, the system needs to support both services in parallel.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

These examples demonstrate the following features of this webhook URL scheme.

First, multiple third-party services can be supported simultaneously. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. In addition, this design makes it possible to incrementally transition from one service provider to another (eg. swapping the payment service gateway) without breaking your own service.

Second, the `{version}` component is independent of the HTTP API's own versioning scheme, and indeed this may vary between individual webhooks. In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhooks are an exception. These are scoped instead to the versions of the _clients_ that interact with the webhook endpoints. After all, it is the client that specifies the interface contract for its webhooks: the HTTP methods, payload structures, authentication and authorization mechanisms, and so on. Usually, the only thing under the control of the server is the URL scheme.

Thus, webhooks MUST be versioned independently to an API's main endpoints, and also to each other. Individual webhooks can thus be incremented independently. It becomes possible to handle two or more incompatible versions of a webhook's event schema in parallel. If a client makes breaking changes to their event schema, you will be able to transition to the new schema in an incremental, non-breaking way. You can do this by publishing a new handler for the new event schema alongside the existing handler for the existing schema, eg.

* `/webhooks/idverse/v3/receive-event`
* `/webhooks/idverse/v4/receive-event`

[TIP]
======
If a client does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the client's own web service API. If this is not possible either, you can invent your own versioning system for the client. The goal is to be able to handle multiple versions of a webhook in parallel.
======

Finally, multiple webhooks can be be supported for a single third-party service. It is often the case that client's require a single webhook via which they can notify subscribers of _all_ events. But sometimes it can be beneficial, or even necessary, to process different types of events (from the same client) in different ways. For example, you may want to process "transaction-initiated" events differently from "transaction-complete" events.

=== Outbound webhook event schema

When designing outbound webhooks, the main consideration is the schema of the events that will be sent to the webhook endpoints of third-party services. The event schema defines the structure and format of the data that will be sent in the webhook payloads. A well-defined event schema is crucial for ensuring that webhook consumers can correctly interpret and process the events they receive.

link:./017-messages.adoc[TS-17: Messages and Events] provides guidance on designing event schemas, including recommended metadata fields and payload structures.

=== Webhook status codes

When integrating with third-party services via inbound webhooks, those third-party services MAY require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the third-party service specifies the status codes that it expects, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular status codes.

If a third-party service does not specify the status codes that it expects, then it is RECOMMENDED to return a `202 Accepted` for all success scenarios. This status code indicates that the request has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook requests, as it allows the server to process the request asynchronously – the webhook message gets added to a queue and processed later – which is a best practice.

To indicate errors, the RECOMMENDED return codes are:

* `400 Bad Request` for client errors, which you should return when a message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization (permissions, scopes) checks.
* `404 Not Found` when the requested resource does not exist. 
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5**` code, you are basically saying to the client "please retry this later".

When designing your own outbound webhook messages, you will need to consider the status codes that you will want third-party services to return in response to your webhook messages. It is RECOMMENDED:


== Versioning

HTTP APIs SHOULD have a major version number that is incremented whenever there are breaking changes in the API. The major version number SHOULD be encoded in the first path segment of the URL.

.Template
----
/v{major}
----

.Example
----
/v1
----

Use the *expanding contract* pattern to maintain backwards compatibility with clients, while incrementally evolving the API's design and capabilities. This is also known as the *additive* approach to building programmatic interfaces.

In practice, this means:

* Breaking changes MUST NOT be made to APIs that are already in use.

* Developers MUST NOT add new required parameters to existing APIs.

* Developers MUST NOT remove existing required parameters.

* Developers MUST NOT change the meaning of existing parameters.

* APIs MUST be designed to be extensible.

A good example of a scalable API design is one that avoids array of scalar data types (strings, integers, etc.). Consider the following example:

[source,json]
----
"countries": [
  "Brazil",
  "France"
]
----

This data structure is impossible to extend without introducing breaking changes. Always prefer arrays of objects, eg.:

[source,json]
----
"countries": [
  { name: "Brazil" },
  { name: "France" }
]
----

Breaking changes include any changes to the request or response message formats, changes to the semantics of the API, or changes to the behavior of the API.

Where breaking changes are unavoidable, the breaking changes MUST be implemented in a new major version of the API. The old version of the API MUST be maintained for a reasonable period of time to allow clients to migrate to the new version. 

APIs MUST have a documented *lifecycle policy*, which describes the support and maintenance of each major version of the API.


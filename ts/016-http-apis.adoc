= TS-16: HTTP APIs
:toc: macro
:toc-title: Contents

This document outlines standards for designing and implementing HTTP APIs. It also covers best practices for the implementation of webhooks (both inbound and outbound).

These standards are applicable to both private HTTP APIs between services within distributed software systems ("inter-service communication") and to public HTTP APIs that are made available for integration into third-party client applications ("web services").

In this technical standard, URLs containing variables are specified according to https://tools.ietf.org/html/rfc6570[IETF RFC 6570: URI Template]. For example, a URL containing a variable called `account_id` would be shown as `https://api.example.com/v1/accounts/{account_id}`.

toc::[]

== General design principles

HTTP APIs, both public and private ones, SHOULD be formed from a consistent set of design patterns – a pattern library. This facilitates a better developer experience and supports greater reuse of code, for example through libraries and software development kits (SDKs), so making integrations quicker and easier.

In broad terms, HTTP APIs SHOULD follow the https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm[RESTful architectural style]. This architecture describes the underlying design principles of the World Wide Web, but particularly of the HTTP protocol and HTML language. In practice, a RESTful API is one that repurposes the semantics of the HTTP protocol, using the full capabilities of HTTP as a messaging and encoding protocol, rather than merely as a transport protocol. In simple terms, a RESTful API uses URLs to represent resources and collections of resources, HTTP methods to represent different types of CRUD-like operations to be performed on those resources, and HTTP status codes to represent outcomes from those operations.

A RESTful API is also:

* *Stateless*: Each request from a client to a server SHOULD contain all the information necessary for the server to understand and fulfil the request. Most client requests SHOULD NOT be dependent upon any particular stored context on the server – with exceptions for things like security measures to protect against denial of service. This design constraint will simplify the server implementation and make it more scalable.

* *Uniform*: A RESTFUL API SHOULD have a highly uniform interface, which means it uses a consistent subset of HTTP methods and status codes, composes message content from a common library of types, and uses a consistent URL structure to represent resources and collections. This constraint will help to simplify client implementations, promote code reuse, and make integrations easier.

* *Cacheable*: As much as possible, responses from a RESTFUL API server SHOULD be cacheable. This helps to reduce load on the server, reduce latency for clients, and supports strategies for fault tolerance and availability.

* *A layered system*: The server application SHOULD have a layered architecture, in which cross-cutting concerns such as security and caching are implemented in discrete layers that span all endpoints of the API.

The following RESTful design constraints are OPTIONAL:

* *Hypermedia as the engine of application state (HATEOAS)*: HTTP APIs MAY embed hypermedia links through which clients can explore the available resources and operations of the API. Clients MAY use the encoded hypermedia controls to read, query, and update application state. This design constraint is not commonly used in practice, but it can be beneficial for some use cases. HATEOAS may be appropriate for APIs that are intended to be consumed directly by human users, who interact with the API through a generic program to explore the available resources and operations, which themselves are constantly evolving. HATEOAS is less useful for APIs that are intended for programmatic integration into other computer systems.

* *Code on demand*: The server MAY send executable code to the client, to extend the functionality of the client. Again, this design constraint is not commonly used in practice, but one possible use case would be for an API to serve updates to SDKs, written in various programming languages, that are dynamically integrated into client applications.

Although most HTTP APIs should be primarily RESTful, or resource-oriented, there are many use cases where a RESTful design is not appropriate. For example, if an API is a thin layer around a legacy system that itself is not designed around resources or fits uncomfortably with the RESTful model, it may be necessary to deviate from RESTful design principles and focus on creating a functional abstraction of the underlying system.

Even within an HTTP API that is predominantly RESTful in its design characteristics, it will often be beneficial to include operations that are more RPC-like in their design. For example, besides the usual create, read, update, and delete operations that are made available on a collection of resources, an HTTP API may augment these operations with additional "actions" that perform tasks on the resources that do not neatly fit the CRUD model, or which abstract multiple CRUD-like operations in a single request. See the section on *Actions* for more information.

In designing an HTTP API, developers SHOULD prioritize creating an accurate model of the system that the API abstracts, rather than trying to religiously adhere to any particular architectural style. Remember, the goal of an HTTP API is to provide a useful and usable interface to a complex system. The best API design will be the one that makes it as easy as possible for clients to interact with the underlying system.

== Authentication and authorization

Authentication and authorization MUST be implemented for all HTTP APIs, including private (internal network) HTTP APIs.

Authentication and authorization is especially important for operations that modify data.

== Security

Security measures MUST be implemented for both public and private APIs. Do not assume that private/internal networks are secure.

All input MUST be validated and sanitized to prevent security vulnerabilities such as SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF).

== HTTP methods

HTTP methods define actions to be performed on a resource or collection of resources.

HTTP methods MUST be used for their designated purpose, as specified by the HTTP standards. This will make it much easier for client applications to be integrated with the API.

HTTP APIs MUST use only the following subset of standard HTTP methods:

|===
|Verb |CRUD usage |Description

|GET
|Read
|Used to retrieve the requested resource. GET operations MUST NOT modify the state of the resource, and there MUST NOT be any other side effects.

|HEAD
|Read
|Used to retrieve only the headers of a resource – it returns the same as GET but without the body.

|POST
|Create
|Used to create a new resource. The server MUST generate a new resource identifier and return it in the response.

|PUT
|Create/Update
|Used to fully replace a resource with the request payload, or to create a new resource in scenarios where the client takes over responsibility from the server for generating a unique identifier for the resource.

|PATCH
|Update
|Used for partial updates to a resource. The request payload SHOULD contain only the fields that are being updated.

|DELETE
|Delete
|Used to delete a resource. Should be repeatable, always with a positive response even if the resource is already deleted.
|===

Other standard HTTP methods are `OPTIONS`, `TRACE`, and `CONNECT`. These are technical methods used to support the HTTP protocol itself, and are not intended the be included in the interface definitions for HTTP APIs.

== HTTP status codes

Appropriate HTTP response codes MUST be used in response messages to indicate the result of API requests. Using the correct codes in responses is not just about adhering to the HTTP protocol, but also about facilitating the correct interpretation of HTTP responses by clients.

There are many standardized HTTP status codes. Most APIs will need only a subset of the full set of standard codes. The supported subset of HTTP status codes MUST be documented as part of the API's interface definition. Commonly-used status codes include:

* *1xx*: Informational response codes.

  ** `100 Continue`: Indicates that the initial part of the request has been received and the client should continue sending the rest of the request.

* *2xx*: Success response codes.

  ** `200 OK`: Indicates that the request was successful. This is the most widely-used success response code.

  ** `201 Created`: Indicates that the request was successful and, as a result, a new resource has been created.

  ** `202 Accepted`: For asynchronous operations that will be fulfilled by the server at a later time.

  ** `204 No Content`: Indicates that the request was successful but there is no content to return in the response message. This status code MUST be returned with an empty HTTP message body.

* *3xx*: Redirection response codes.

  ** `301 Moved Permanently`: Indicates that the requested URL has been changed permanently. The new URL MUST be specified in the response.

  ** `302 Found`: Indicates that the requested resource is temporarily under a different URL.

* *4xx*: Client error response codes.

  ** `400 Bad Request`: Indicates that the request cannot be understood or processed by the server due to a syntax error in the client's request message.

  ** `401 Unauthorized`: Indicates that the request requires authentication but the client has not authenticated itself.

  ** `403 Forbidden`: Indicates that the server understood the request but is refusing to authorize access to the specific resource requested.

  ** `404 Not Found`: Indicates that the server could not find the requested resource.

  ** `405 Method Not Allowed`: Indicates that the HTTP method used in the request is not allowed on the target resource (but the resource exists and other methods can be run on it).

* *5xx*: Server error response codes.

  ** `500 Internal Server Error`: Indicates that the server encountered a situation it doesn't know how to handle.

  ** `502 Bad Gateway`: Indicates that the server, while acting as a gateway or proxy, received an invalid response from an upstream server.

  ** `503 Service Unavailable`: Indicates that the server is not ready to handle the request, typically due to maintenance or overload.

== URLs

URLs identify resources, collections of resources, and actions.

=== Path delimiters

The forward slash (`/`) character is used to delimit between path segments in URLs.

API documentation SHOULD be consistent in its use of trailing slashes. It is RECOMMENDED that trailing slashes be omitted in documentation. However, an API SHOULD accept requests with or without a trailing slash, but SHOULD NOT respond with a redirect to the canonical version.

.Postel's Law (aka. the Robustness Principle)
****
Be liberal in what you accept, and conservative in what you send.
****

=== Versioning

HTTP APIs MUST be versioned, and version information SHOULD be encoded in the URL path. This pattern is widely used for its simplicity of use by clients and compatibility with caching and proxying systems (compared to alternative designs such as header-based versioning).

HTTP APIs MUST use https://semver.org/[Semantic Versioning], as specified in *link:./005-versioning.adoc[TS-5: Versioning]*. However, only the major version number needs to be exposed in the URL schema.

It is RECOMMENDED that the major version number be the first segment of the URL path, eg. `/v1`. This tends to make it easier for clients to implement version-specific behavior, and it also tends to make it easier to maintain and deploy multiple major versions of an API in parallel on the server side.

.Template
----
/v{major}
----

.Example
----
/v1
----

See the *Versioning* section, below, for more guidance on HTTP API versioning.

=== Namespaces

The next part of the URL path SHOULD be treated as a "namespace" in which related resources will be grouped.

Namespaces are used to create logical groups of resources, collections, and actions. But they do not necessarily map directly to modules or back-end services that are responsible for fulfilling requests. Namespaces SHOULD reflect the customer's perspective of how the product works. That perspective may not necessarily reflect the internal structure of the system, or the business domains and subdomains.

.Template
----
/v{major}/{namespace}
----

.Example
----
/v1/vault
----

Namespaces SHOULD be nouns but MAY be either singular or plural, as appropriate for each grouping of resources, collections, and actions.

=== Resources and collections

The remaining segments of a URL path are used to identify resources and collections of resources,

Consistent path components SHOULD be used to refer to the same resources, and collections of them, across different endpoints.

.Templates
----
GET /v{major}/{namespace}/{resource}
GET /v{major}/{namespace}/{resource}/{resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}
----

Sub-resources and sub-collections MAY be supported, too.

.Templates
----
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}
GET /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
POST /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PUT /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
PATCH /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
DELETE /v{major}/{namespace}/{resource}/{resource_id}/{sub_resource}/{sub_resource_id}
----

The `{resource}` and `{sub_resource}` components SHOULD be named using nouns. These SHOULD be in the singular form where there is only ever one instance of the resource, and never a collection of resources of the same type. More commonly, there will be collections of each type of resource and sub-resource, and these SHOULD be named in the plural form.

Resource-oriented endpoints SHOULD use lowercase hyphen-delimited slugs to name resources and sub-resources. Examples: "account", "users", "billing", "charge-points", "charge-points/{charge_point_id}/sessions", "credit-cards", "credit-cards/{credit_card_id}/transactions".

== Webhooks

Webhooks are API endpoints that are typically used to receive notifications about events that happen in third-party systems, such as when a payment has been successfully processed, when a subscription is cancelled, or when a service fails to send an SMS message.

Webhooks take two forms, each of which requires different design considerations:

* *Inbound webhooks*: These are _private_ endpoints that your service exposes to receive notifications from one or more third-party services.

* *Outbound webhooks*: These are messages sent out from a service to the webhook endpoints of other services.

Inbound webhooks are not really part of an HTTP API's public interface, but rather they are special-purpose private endpoints that sit alongside the main public endpoints of an HTTP API. Their purpose is to facilitate integration with other services (usually services operated by third-parties). They are not used directly by the service's own users/customers. Inbound webhooks may be exposed via different URLs schemas and HTTP methods than the main API endpoints, and things like payload schema and authentication mechanisms will be determined by the third-party services.

Outbound webhooks, on the other hand, are a form of event notification, and they are very much part of the application programming interface (API) of the service from which they are emitted. And yet they may sit apart from the main HTTP API endpoints of that service. Outbound webhooks may use different transport protocols, different message formats, different schemas, different methods of authentication, and they may even be versioned independently of the service's main API.

****
See also link:./017-messages.adoc[TS-17: Messages and Events], which covers concerns related to event schema and asynchronous event handling – topics that are relevant to the implementation of webhooks.
****

=== Webhook URL schemes

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/webhooks/{party}/{namespace}/v{version}/{event_type}/{…}
----

Where:

* `{party}` is the name of the third-party service that is authorized to use the endpoint.

* `{namespace}` is an optional path component used to scope a webhook to a particular service of the third-party.

* `{version}` identifies the version number of the third-party's webhook API or event schema that is supported by the endpoint.

* `{event_type}` is a component that identifies a particular type of event that the endpoint is designed to subscribe to. (This can simply be the word "event" if all that is needed is a single endpoint to process all kinds of events emitted by a third-party service.)

* `{…}` refers to any additional URL path components that are required by the client in the webhook implementation, for example for the purpose of passing resource identifiers.

Consider the following examples of webhook URLs, which use the above scheme:

* `/webhooks/authentiq/v3/event`
* `/webhooks/true-id/v1/event`
* `/webhooks/transactify/v1/transaction-initiated`
* `/webhooks/transactify/v1/transaction-complete`
* `/webhooks/transactify/v2/transaction-initiated`
* `/webhooks/transactify/v2/transaction-complete`

This fictional API exposes six webhook endpoints, which are used to receive notifications from three different third-party services:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this service. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* A similar webhook is for a service called TrueID. The endpoint supports version 1 of TrueID's webhook event schema. We're pretending that TrueID is a legacy identity verification service that is being phased out, and eventually replaced by AuthentiQ. In this transition phase, the system needs to support both services in parallel.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

These examples demonstrate the following features of this webhook URL scheme.

First, multiple third-party services can be supported simultaneously. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. In addition, this design makes it possible to incrementally transition from one service provider to another (eg. swapping the payment service gateway) without breaking your own service.

Second, the `{version}` component is independent of the HTTP API's own versioning scheme, and indeed this may vary between individual webhooks. In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhooks are an exception. These are scoped instead to the versions of the _clients_ that interact with the webhook endpoints. After all, it is the client that specifies the interface contract for its webhooks: the HTTP methods, payload structures, authentication and authorization mechanisms, and so on. Usually, the only thing under the control of the server is the URL scheme.

Thus, webhooks MUST be versioned independently to an API's main endpoints, and also to each other. Individual webhooks can thus be incremented independently. It becomes possible to handle two or more incompatible versions of a webhook's event schema in parallel. If a client makes breaking changes to their event schema, you will be able to transition to the new schema in an incremental, non-breaking way. You can do this by publishing a new handler for the new event schema alongside the existing handler for the existing schema, eg.

* `/webhooks/idverse/v3/receive-event`
* `/webhooks/idverse/v4/receive-event`

[TIP]
======
If a client does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the client's own web service API. If this is not possible either, you can invent your own versioning system for the client. The goal is to be able to handle multiple versions of a webhook in parallel.
======

Finally, multiple webhooks can be be supported for a single third-party service. It is often the case that client's require a single webhook via which they can notify subscribers of _all_ events. But sometimes it can be beneficial, or even necessary, to process different types of events (from the same client) in different ways. For example, you may want to process "transaction-initiated" events differently from "transaction-complete" events.

=== Outbound webhook event schema

When designing outbound webhooks, the main consideration is the schema of the events that will be sent to the webhook endpoints of third-party services. The event schema defines the structure and format of the data that will be sent in the webhook payloads. A well-defined event schema is crucial for ensuring that webhook consumers can correctly interpret and process the events they receive.

link:./017-messages.adoc[TS-17: Messages and Events] provides guidance on designing event schemas, including recommended metadata fields and payload structures.

=== Webhook status codes

When integrating with third-party services via inbound webhooks, those third-party services MAY require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the third-party service specifies the status codes that it expects, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular status codes.

If a third-party service does not specify the status codes that it expects, then it is RECOMMENDED to return a `202 Accepted` for all success scenarios. This status code indicates that the request has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook requests, as it allows the server to process the request asynchronously – the webhook message gets added to a queue and processed later – which is a best practice.

To indicate errors, the RECOMMENDED return codes are:

* `400 Bad Request` for client errors, which you should return when a message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization (permissions, scopes) checks.
* `404 Not Found` when the requested resource does not exist. 
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5**` code, you are basically saying to the client "please retry this later".

When designing your own outbound webhook messages, you will need to consider the status codes that you will want third-party services to return in response to your webhook messages. It is RECOMMENDED:

* To accept any `2**` status code to indicate successful processing of a webhook message (ie. any `2**` code will be treated by you as `202 Accepted`).
* To log any `4**` status codes for further investigation, 
* To treat `5**` status codes as server errors, which will feed into your retry and dead-letter queue mechanisms.
* To treat any `4**` client errors in the same way as `5**` server errors, but in addition log them for further investigation.
* To treat `1**` and `3**` status codes as generic `500` server errors.

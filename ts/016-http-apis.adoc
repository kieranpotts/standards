= TS-16: HTTP APIs
:toc: macro
:toc-title: Contents

This technical standard covers best practices for designing HTTP APIs, including resource-oriented "RESTful" APIs, RPC-like APIs, webhooks, and considerations for security, versioning, and documentation.

toc::[]

== Webhooks

Webhooks are API endpoints that are typically used to receive notifications about events that happen in third-party systems, such as when a payment has been successfully processed, when a subscription is cancelled, or when a service fails to send an SMS message.

Webhooks take two forms, each of which requires different design considerations:

* *Inbound webhooks*: These are _private_ endpoints that your service exposes to receive notifications from one or more third-party services.

* *Outbound webhooks*: These are messages sent out from a service to the webhook endpoints of other services.

Inbound webhooks are not really part of an HTTP API's public interface, but rather they are special-purpose private endpoints that sit alongside the main public endpoints of an HTTP API. Their purpose is to facilitate integration with other services (usually services operated by third-parties). They are not used directly by the service's own users/customers. Inbound webhooks may be exposed via different URLs schemas and HTTP methods than the main API endpoints, and things like payload schema and authentication mechanisms will be determined by the third-party services.

Outbound webhooks, on the other hand, are a form of event notification, and they are very much part of the application programming interface (API) of the service from which they are emitted. And yet they may sit apart from the main HTTP API endpoints of that service. Outbound webhooks may use different transport protocols, different message formats, different schemas, different methods of authentication, and they may even be versioned independently of the service's main API.

****
See also link:./017-messages.adoc[TS-17: Messages and Events], which covers concerns related to event schema and asynchronous event handling – topics that are relevant to the implementation of webhooks.
****

=== Webhook URL schemes

The following URL scheme is RECOMMENDED for inbound webhooks.

----
/webhooks/{party}/{namespace}/v{version}/{event_type}/{…}
----

Where:

* `{party}` is the name of the third-party service that is authorized to use the endpoint.

* `{namespace}` is an optional path component used to scope a webhook to a particular service of the third-party.

* `{version}` identifies the version number of the third-party's webhook API or event schema that is supported by the endpoint.

* `{event_type}` is a component that identifies a particular type of event that the endpoint is designed to subscribe to. (This can simply be the word "event" if all that is needed is a single endpoint to process all kinds of events emitted by a third-party service.)

* `{…}` refers to any additional URL path components that are required by the client in the webhook implementation, for example for the purpose of passing resource identifiers.

Consider the following examples of webhook URLs, which use the above scheme:

* `/webhooks/authentiq/v3/event`
* `/webhooks/true-id/v1/event`
* `/webhooks/transactify/v1/transaction-initiated`
* `/webhooks/transactify/v1/transaction-complete`
* `/webhooks/transactify/v2/transaction-initiated`
* `/webhooks/transactify/v2/transaction-complete`

This fictional API exposes six webhook endpoints, which are used to receive notifications from three different third-party services:

* One webhook is for a service called AthentiQ. A single endpoint is used to process all events emitted by this service. The endpoint supports version 3 of AuthentiQ's webhook event schema.

* A similar webhook is for a service called TrueID. The endpoint supports version 1 of TrueID's webhook event schema. We're pretending that TrueID is a legacy identity verification service that is being phased out, and eventually replaced by AuthentiQ. In this transition phase, the system needs to support both services in parallel.

* Four endpoints handle notifications from a service called Transactify. There's one endpoint to process "transaction-initiated" events, and another endpoint to process "transaction-complete" events. The system supports two different versions of Transactify's event schema. Perhaps most notifications are now sent to the v2 webhooks, but the system still needs to support the legacy v1 schema for a period of time, for example to handle retries and updates of historical events, before its deprecation.

These examples demonstrate the following features of this webhook URL scheme.

First, multiple third-party services can be supported simultaneously. It might be necessary, for example, to have one or more webhooks for a payment service gateway, other webhooks for a transactional email service, and yet more webhooks for an identity verification service. In addition, this design makes it possible to incrementally transition from one service provider to another (eg. swapping the payment service gateway) without breaking your own service.

Second, the `{version}` component is independent of the HTTP API's own versioning scheme, and indeed this may vary between individual webhooks. In an HTTP API, most endpoints will be scoped to a particular version of the API service itself. But webhooks are an exception. These are scoped instead to the versions of the _clients_ that interact with the webhook endpoints. After all, it is the client that specifies the interface contract for its webhooks: the HTTP methods, payload structures, authentication and authorization mechanisms, and so on. Usually, the only thing under the control of the server is the URL scheme.

Thus, webhooks MUST be versioned independently to an API's main endpoints, and also to each other. Individual webhooks can thus be incremented independently. It becomes possible to handle two or more incompatible versions of a webhook's event schema in parallel. If a client makes breaking changes to their event schema, you will be able to transition to the new schema in an incremental, non-breaking way. You can do this by publishing a new handler for the new event schema alongside the existing handler for the existing schema, eg.

* `/webhooks/idverse/v3/receive-event`
* `/webhooks/idverse/v4/receive-event`

[TIP]
======
If a client does not explicitly version their webhook payload schema – this happens often! – then it is RECOMMENDED to scope the webhook URLs to the current major version of the client's own web service API. If this is not possible either, you can invent your own versioning system for the client. The goal is to be able to handle multiple versions of a webhook in parallel.
======

Finally, multiple webhooks can be be supported for a single third-party service. It is often the case that client's require a single webhook via which they can notify subscribers of _all_ events. But sometimes it can be beneficial, or even necessary, to process different types of events (from the same client) in different ways. For example, you may want to process "transaction-initiated" events differently from "transaction-complete" events.

=== Outbound webhook event schema

When designing outbound webhooks, the main consideration is the schema of the events that will be sent to the webhook endpoints of third-party services. The event schema defines the structure and format of the data that will be sent in the webhook payloads. A well-defined event schema is crucial for ensuring that webhook consumers can correctly interpret and process the events they receive.

link:./017-messages.adoc[TS-17: Messages and Events] provides guidance on designing event schemas, including recommended metadata fields and payload structures.

=== Webhook status codes

When integrating with third-party services via inbound webhooks, those third-party services MAY require you to return specific status codes to indicate success or failure in your processing of their webhook messages. If the third-party service specifies the status codes that it expects, then you MUST comply with those requirements to ensure proper integration with their systems. Processes such as retries and dead-letter queues will likely be triggered by particular status codes.

If a third-party service does not specify the status codes that it expects, then it is RECOMMENDED to return a `202 Accepted` for all success scenarios. This status code indicates that the request has been accepted for processing, but the processing has not been done yet. This is appropriate for most webhook requests, as it allows the server to process the request asynchronously – the webhook message gets added to a queue and processed later – which is a best practice.

To indicate errors, the RECOMMENDED return codes are:

* `400 Bad Request` for client errors, which you should return when a message fails to validate against the expected schema.
* `401 Unauthorized` for failed authentication checks.
* `403 Forbidden` for failed authorization (permissions, scopes) checks.
* `404 Not Found` when the requested resource does not exist. 
* `500 Internal Server Error` for any scenario in which your application encounters an unexpected condition that prevents it from completing its handling of the message. When you return a `5**` code, you are basically saying to the client "please retry this later".

When designing your own outbound webhook messages, you will need to consider the status codes that you will want third-party services to return in response to your webhook messages. It is RECOMMENDED:

* To accept any `2**` status code to indicate successful processing of a webhook message (ie. any `2**` code will be treated by you as `202 Accepted`).
* To log any `4**` status codes for further investigation, 
* To treat `5**` status codes as server errors, which will feed into your retry and dead-letter queue mechanisms.
* To treat any `4**` client errors in the same way as `5**` server errors, but in addition log them for further investigation.
* To treat `1**` and `3**` status codes as generic `500` server errors.
